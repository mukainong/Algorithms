************************************************************************************************************
*Problem - Fibonacci 
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public int fib(int n) {
        if (n <= 1) return n;
        return fib(n-1) + fib(n-2);
    }
}

public class Solution {
    public int fib(int n) {
        int[] f = new int[n+1];
 
        f[0] = 0;
        f[1] = 1;
 
        for (int i = 2; i <= n; i++)
            f[i] = f[i-1] + f[i-2];
            
        return f[n];
    }
}


************************************************************************************************************
*Problem - Factorial
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public int factorial(int n) {
        if (n == 0) return 1;
	return n * Factorial(n-1);
    }
}

public class Solution {
    public int factorial(int n) {
        int x, fact = 1;
  	for(x = input; x > 1; x--)
            fact *= x;
  	return fact;
    }
}


************************************************************************************************************
*Problem - Selection sort
*
*Parameter: (int[] a)
************************************************************************************************************
public class SelectionSort {
    public static int[] selectionSort(int[] a) {
        int i, j;
        for(i = 0; i < a.length; i++)
            for(j = i; j < a.length; j++)
                if(a[i] > a[j])
                    swap(a, i, j);
        return a;
    }
    
    public static void swap(int[] a, int i, int j) {
        int tem = a[i];
        a[i] = a[j];
        a[j] = tem;
    }
    
    public static void main(String[] args) {
        int[] a = {1,2,4,2,5,3,6,8,3,10,9};
        System.out.println(Arrays.toString(selectionSort(a)));
    }
}


************************************************************************************************************
*Problem - Insertion sort (UW CSE373)
*
*Parameter: (int[] a)
************************************************************************************************************
public class InsertionSort {
    public static int[] insertionSort(int[] a) {
        int i, j;
        for(i = 0; i < a.length; i++) {
            int temp = a[i];
            for(j = i; j > 0 && temp < a[j-1]; j--)
                a[j] = a[j-1];
            a[j] = temp;
        }
        return a;
    }
    
    public static void main(String[] args) {
        int[] a = {1,2,4,2,5,3,6,8,3,10,9};
        System.out.println(Arrays.toString(insertionSort(a)));
    }
}


************************************************************************************************************
*Problem - Bubble sort
*
*Parameter: (int[] a)
************************************************************************************************************
public class BubbleSort {
    public static int[] bubbleSort(int[] a) {
        int i, j;
        for(i = 0; i < a.length-1; i++) {
            for(j = a.length-2; j > i; j--)
                if(a[j] > a[j+1])
                    swap(a, j, j+1);
        }
        return a;
    }
    
    public static void swap(int[] a, int i, int j) {
        int tem = a[i];
        a[i] = a[j];
        a[j] = tem;
    }
    
    public static void main(String[] args) {
        int[] a = {1,2,4,2,5,3,6,8,3,10,9};
        System.out.println(Arrays.toString(bubbleSort(a)));
    }
}


************************************************************************************************************
*Problem - Quick sort (algolist)
*
*Parameter: (int[] arr,int left,int right)
************************************************************************************************************
public class QuickSort {
    public static void quickSort(int[] arr, int left, int right) {
        int i = partition(arr, left, right);
        if (left < i - 1) quickSort(arr, left, i - 1);
        if (i < right) quickSort(arr, i, right);
    }

    private static int partition(int[] arr, int left, int right) {
        int i = left, j = right;
        int tmp;
        int pivot = arr[(left+right)/2];
     
        while (i <= j) {
            while (arr[i] < pivot) i++;
            while (arr[j] > pivot) j--;
            if (i <= j) {
                tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
                i++;
                j--;
            }
        };
     
        return i;
    }
    
    public static void main(String[] args) {
        int[] a = {1,2,4,2,5,3,6,8,3,10,9};
        quickSort(a, 0, a.length-1);
        System.out.println(Arrays.toString(a));
    }
}


public class Solution2 {
    public void quickSort(int[] arr, int left, int right) {
        int i = left, j = right, tmp;

        int pivot = arr[(left+right)/2];
 
        /* partition */
        while (i <= j) {
            while (arr[i] < pivot) i++;
            while (arr[j] > pivot) j--;
            if (i <= j) { // Swap
                tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
                i++;
                j--;
            }
        };

        /* recursion */
        if (left < j) quickSort(arr, left, j);
        if (i < right) quickSort(arr, i, right);
    }
}


************************************************************************************************************
*Problem - Merge sort
*
*Parameter: (int[] a,int low,int high)
************************************************************************************************************
public class MergeSort {
    public static void sort(int[] in){
        if(in.length <2) return; //do not need to sort
        int mid = in.length/2;

        int left[] = new int[mid];
        int right[] = new int[in.length-mid];
        for(int i=0; i<mid; i++){ //copy left
            left[i] = in[i];
        }
        for(int i=0; i<in.length-mid; i++){ //copy right
            right[i] = in[mid+i];
        }

        sort(left);
        sort(right);
        merge(left, right, in);
    }

    private static void merge(int[] a, int[] b, int[] all){
        int i=0, j=0, k=0;
        while(i<a.length && j<b.length){ //merge back
            if(a[i] < b[j])
                all[k++] = a[i++];
            else
                all[k++] = b[j++];
        }
        while(i<a.length){ //left remaining
            all[k++] = a[i++];
        }
        while(j<b.length){ //right remaining
            all[k++] = b[j++];
        }
    }

    public static void main(String[] args){
        int[] a = {2,2,3,6,4,9,22,12,1};
        sort(a);    
        for(int j=0; j<a.length; j++){
           System.out.print(a[j] + " ");
        }
	System.out.println(Arrays.toString(a));
    }
}


************************************************************************************************************
*Problem - Merge 
*
*Parameter: (int[] a, int[] b)
************************************************************************************************************
public class Solution {
    public static int[] merge(int[] a, int[] b) {
        int[] answer = new int[a.length + b.length];
        int i = 0, j = 0, k = 0;

        while (i < a.length && j < b.length) {
            if (a[i] < b[j])       
                answer[k++] = a[i++];
            else        
                answer[k++] = b[j++];               
        }

        while (i < a.length)  
            answer[k++] = a[i++];

        while (j < b.length)    
            answer[k++] = b[j++];

        return answer;
    }
}


************************************************************************************************************
*Problem - Binary search
*
*Parameter: (int[] A, int target)
************************************************************************************************************
public class Solution {
    public int binarySearch(int[] A, int target) {
        int L = 0, R = A.length - 1;
        while (L < R) {
            int M = (L + R) / 2;
            if (A[M] < target) {
                L = M + 1;
            } else {
                R = M; 
            }
        }
        return (A[L] < target) ? L + 1 : L;
    }
}


************************************************************************************************************
*Problem 1 - Two Sum 
*
*Description:Given an array of integers, find two numbers such that they add up to a specific target number.
*	     The function twoSum should return indices of the two numbers such that they add up to the
*	     target, where index1 must be less than index2. Please note that your returned answers
*	     (both index1 and index2) are not zero-based.
*
*	     You may assume that each input would have exactly one solution.
*	     
*	     	Input: numbers={2, 7, 11, 15}, target=9
*	     	Output: index1=1, index2=2
*
*Parameter: (int[] nums, int target)
************************************************************************************************************
public class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int[] result = new int[2];
        
        for (int i = 0 ; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) {
                result[0] = map.get(target - nums[i]) + 1;
                result[1] = i + 1;
                return result;
            }
            map.put(nums[i], i);
        }
        
        return result;
    }
}


************************************************************************************************************
*Problem 2 - Add Two Numbers  
*
*Description:You are given two linked lists representing two non-negative numbers.
*	     The digits are stored in reverse order and each of their nodes contain a single digit.
*	     Add the two numbers and return it as a linked list.
*
*	     	Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
*	     	Output: 7 -> 0 -> 8
*
*Parameter: (ListNode l1, ListNode l2)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1, q = l2, curr = dummyHead;
        int carry = 0;
        while (p != null || q != null) {
            int x = (p != null) ? p.val : 0;
            int y = (q != null) ? q.val : 0;
            int digit = carry + x + y;
            carry = digit / 10;
            curr.next = new ListNode(digit % 10);
            curr = curr.next;
            if (p != null) p = p.next;
            if (q != null) q = q.next;
        }
        if (carry > 0) {
            curr.next = new ListNode(carry);
        }
        return dummyHead.next;
    }
}


************************************************************************************************************
*Problem 3 - Longest Substring Without Repeating Characters 
*
*Description:Given a string, find the length of the longest substring without repeating characters. 
*	     For example, the longest substring without repeating letters for "abcabcbb" is "abc", which 
*	     the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        boolean[] set = new boolean[256];
        int i = 0, max = 0;
        for (int j = 0; j < s.length(); j++) { // TWO POINTERS
            while (set[s.charAt(j)]) {
                set[s.charAt(i)] =false;
                i++;
            }
            set[s.charAt(j)] = true;
            max = Math.max(j - i + 1, max);
        }
        return max;
    }
}

public class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length()==0) return 0;
        Map<Character, Integer> map = new HashMap<>();
        int max=0, j=0;
        for (int i=0; i<s.length(); i++){
            if (map.containsKey(s.charAt(i))){
                j = Math.max(j,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            max = Math.max(max,i-j+1);
        }
        return max;
    }
}


************************************************************************************************************
*Problem 4 - Median of Two Sorted Arrays 
*
*Description:There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of 
*	     the two sorted arrays. The overall run time complexity should be O(log (m+n)). 
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
        int m = A.length, n = B.length;
        int l = (m + n + 1) / 2;
        int r = (m + n + 2) / 2;
        return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;
    }

    public double getkth(int[] A, int aStart, int[] B, int bStart, int k) {
        if (aStart > A.length - 1) return B[bStart + k - 1];            
        if (bStart > B.length - 1) return A[aStart + k - 1];                
        if (k == 1) return Math.min(A[aStart], B[bStart]);

        int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;
        if (aStart + k/2 - 1 < A.length) aMid = A[aStart + k/2 - 1]; 
        if (bStart + k/2 - 1 < B.length) bMid = B[bStart + k/2 - 1];        

        if (aMid < bMid) 
            return getkth(A, aStart + k/2, B, bStart,       k - k/2);// Check: aRight + bLeft 
        else 
            return getkth(A, aStart,       B, bStart + k/2, k - k/2);// Check: bRight + aLeft
    }
}


************************************************************************************************************
*Problem 5 - Longest Palindromic Substring 
*
*Description:Given a string S, find the longest palindromic substring in S. You may assume that the maximum 
*	     length of S is 1000, and there exists one unique longest palindromic substring. 
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public String longestPalindrome(String s) {
        String res = "";
        int currLength = 0;
        for(int i=0;i<s.length();i++){
            if(isPalindrome(s,i-currLength-1,i)){
                res = s.substring(i-currLength-1,i+1);
                currLength = currLength+2;
            }
            else if(isPalindrome(s,i-currLength,i)){
                res = s.substring(i-currLength,i+1);
                currLength = currLength+1;
            }
        }
        return res;
    }

    public boolean isPalindrome(String s, int begin, int end){
        if(begin<0) return false;
        while(begin<end){
            if(s.charAt(begin++)!=s.charAt(end--)) return false;
        }
        return true;
    }
}


************************************************************************************************************
*Problem 6 - ZigZag Conversion 
*
*Description:Write the code that will take a string and make this conversion given a number of rows. 
*
*Parameter: (String s, int numRows)
************************************************************************************************************



************************************************************************************************************
*Problem 7 - Reverse Integer
*
*Description:Reverse digits of an integer.
*	     Example1: x = 123, return 321
*	     Example2: x = -123, return -321
*
*Parameter: (int x)
************************************************************************************************************
public class Solution {
    public int reverse(int x) {
        int ret = 0;
        while (x != 0) {
            // HANDLE OVERFLOW/UNDERFLOW
            if (Math.abs(ret) > 214748364) {
                return 0;
            }
            ret = ret * 10 + x % 10;
            x /= 10;
        }
        return ret;
    }
}


************************************************************************************************************
*Problem 8 - String to Integer (atoi) 
*
*Description:Implement atoi to convert a string to an integer.
*
*Parameter: (String str)
************************************************************************************************************
public class Solution {
    private static final int maxDiv10 = Integer.MAX_VALUE / 10;
    
    public int myAtoi(String str) {
        int i = 0, n = str.length();
        
        while (i < n && Character.isWhitespace(str.charAt(i))) i++;
        
        int sign = 1;
        
        if (i < n && str.charAt(i) == '+') {
            i++;
        } else if (i < n && str.charAt(i) == '-') {
            sign = -1;
            i++;
        }
        
        int num = 0;
        
        while (i < n && Character.isDigit(str.charAt(i))) {
            int digit = Character.getNumericValue(str.charAt(i));
            
            if (num > maxDiv10 || num == maxDiv10 && digit >= 8) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            
            num = num * 10 + digit;
            i++;
        }
        return sign * num;
    }
}


************************************************************************************************************
*Problem 9 - Palindrome Number 
*
*Description:Determine whether an integer is a palindrome. Do this without extra space.
*
*Parameter: (int x)
************************************************************************************************************
public class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0) return false;
        
        int div = 1;
        
        while (x / div >= 10) {
            div *= 10;
        }
        
        while (x != 0) {
            if (x / div != x % 10) return false;
            x = (x % div) / 10;
            div /= 100;
        }
        return true;
    }
}


************************************************************************************************************
*Problem 10 - Regular Expression Matching 
*
*Description:Implement regular expression matching with support for '.' and '*'.
*
*	’.’ Matches any single character.
*	’*’ Matches zero or more of the preceding element.
*
*	The matching should cover the entire input string (not partial).
*
*	The function prototype should be:
*	bool isMatch(const char *s, const char *p)
*
*	Some examples:
*	isMatch("aa","a") → false
*	isMatch("aa","aa") → true
*	isMatch("aaa","aa") → false
*	isMatch("aa", "a*") → true
*	isMatch("aa", ".*") → true
*	isMatch("ab", ".*") → true
*	isMatch("aab", "c*a*b") → true
*
*Parameter: (int x)
************************************************************************************************************
public class Solution {
    public boolean isMatch(String s, String p) {
        for(int i = 0; i < p.length(); s = s.substring(1)) {
            char c = p.charAt(i);
            if(i + 1 >= p.length() || p.charAt(i + 1) != '*')
                i++;
            else if(isMatch(s, p.substring(i + 2)))
                return true;

            if(s.isEmpty() || (c != '.' && c != s.charAt(0)))
                return false;
        }
        return s.isEmpty();
    }
}


************************************************************************************************************
*Problem 11 - Container With Most Water
*
*Description:Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai).
*	     n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). 
*	     Find two lines, which together with x-axis forms a container, such that the container contains the 
*	     most water.
*	     
*	     Note: You may not slant the container.
*
*Parameter: (int[] height)
************************************************************************************************************
public class Solution {
    public int maxArea(int[] height) {
        int areaMax = 0;
        int left = 0, right = height.length-1;
        
        while(left < right) {
            if(areaMax < (right - left)*Math.min(height[left], height[right])){
                areaMax = (right - left)*Math.min(height[left], height[right]);
            }
            
            if(height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return areaMax;
    }
}


************************************************************************************************************
*Problem 12 - Integer to Roman 
*
*Description:Given an integer, convert it to a roman numeral. 
*	     Input is guaranteed to be within the range from 1 to 3999.
*
*Parameter: (int num)
************************************************************************************************************
public class Solution {
    private static final int[] values = {
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    };
    
    private static final String[] symbols = {
        "M", "CM", "D", "CD",
        "C", "XC", "L", "XL",
        "X", "IX", "V", "IV", 
        "I",
    };
    
    public String intToRoman(int num) {
        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (num > 0) {
            int k = num / values[i];
            for (int j = 0; j < k; j++) {
                sb.append(symbols[i]);
                num -= values[i];
            }
            i++;
        }
        return sb.toString();
    }
}


************************************************************************************************************
*Problem 13 - Roman to Integer (easier)
*
*Description:Given a roman numeral, convert it to an integer.
*	     Input is guaranteed to be within the range from 1 to 3999.
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    private Map<Character, Integer> map = new HashMap<Character, Integer>() {{
            put('I', 1); put('V', 5); put('X', 10); 
            put('L', 50); put('C', 100); put('D', 500); 
            put('M', 1000); 
    }};
    
    public int romanToInt(String s) {
        int prev = 0, total = 0;
        
        for (char c : s.toCharArray()) {
            int curr = map.get(c);
            total += (curr > prev) ? (curr - 2 * prev) : curr;
            prev = curr;
        }
        return total;
    }
}


************************************************************************************************************
*Problem 14 - Longest Common Prefix
*
*Description:Write a function to find the longest common prefix string amongst an array of strings.
*
*Parameter: (String[] strs)
************************************************************************************************************
public class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0) return "";
 
        int minLen=Integer.MAX_VALUE;
        for(String str: strs){
            if(minLen > str.length())
                minLen = str.length(); // FETCH SHORTEST LENGTH
        }
        if(minLen == 0) return "";
 
        for(int j=0; j<minLen; j++){
            char prev='0';
            for(int i=0; i<strs.length ;i++){
                if(i==0) {
                    prev = strs[i].charAt(j); // ASSIGN SINGLE DIGIT
                    continue;
                }
 
                if(strs[i].charAt(j) != prev){ // COMPARE THIS POSITION DIGIT WITH SUBSEQUENT STRINGS
                    return strs[i].substring(0, j);
                }
            }
        }
 
        return strs[0].substring(0,minLen);
    }
}


************************************************************************************************************
*Problem 15 - 3Sum
*
*Description:Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find 
*	     all unique triplets in the array which gives the sum of zero.
*	     Note:
*	     	Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
*	     	The solution set must not contain duplicate triplets. 
*	     For example, given array S = {-1 0 1 2 -1 -4},
*	     A solution set is:
*	     (-1, 0, 1)
*	     (-1, -1, 2)
*
*Parameter: (ListNode head)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> threeSum(int[] num) {
        Arrays.sort(num);
        List<List<Integer>> res = new LinkedList<>(); 
        for (int i = 0; i < num.length-2; i++) {
            if (i == 0 || (i > 0 && num[i] != num[i-1])) {
                int lo = i+1, hi = num.length-1, sum = 0 - num[i];
                while (lo < hi) {
                    if (num[lo] + num[hi] == sum) {
                        res.add(Arrays.asList(num[i], num[lo], num[hi]));
                        while (lo < hi && num[lo] == num[lo+1]) lo++;
                        while (lo < hi && num[hi] == num[hi-1]) hi--;
                        lo++; hi--;
                    } else if (num[lo] + num[hi] < sum) {
                        lo++;
                    } else 
                        hi--;
                }
            }
        }
        return res;
    }
}


************************************************************************************************************
*Problem 16 - 3Sum Closest
*
*Description:Given an array S of n integers, find three integers in S such that the sum is closest to a given 
*	     number, target. Return the sum of the three integers. You may assume that each input would
*	     have exactly one solution.
*	    
*	     For example, given array S = {-1 2 1 -4}, and target = 1.
*	     The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 
*
*Parameter: (int[] nums, int target)
************************************************************************************************************
public class Solution {
    public int threeSumClosest(int[] num, int target) {
        int result = num[0] + num[1] + num[num.length - 1];
        Arrays.sort(num);
        for (int i = 0; i < num.length - 2; i++) {
            int start = i + 1, end = num.length - 1;
            while (start < end) {
                int sum = num[i] + num[start] + num[end];
                if (sum > target) {
                    end--;
                } else {
                    start++;
                }
                if (Math.abs(sum - target) < Math.abs(result - target)) {
                    result = sum;
                }
            }
        }
        return result;
    }
}


************************************************************************************************************
*Problem 17 - Letter Combinations of a Phone Number 
*
*Description:Given a digit string, return all possible letter combinations that the number could represent. 
*	     A mapping of digit to letters (just like on the telephone buttons) is given below.
*	     
*	     Input:Digit string "23"
*	     Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    // DRIVER METHOD
    public List<String> letterCombinations(String digits) {
        if(digits.isEmpty()){
            return new ArrayList<String>();
        }
        
        Map<String, String> map = new HashMap<String, String>(){{
            put("2", "abc");
            put("3", "def");
            put("4", "ghi");
            put("5", "jkl");
            put("6", "mno");
            put("7", "pqrs");
            put("8", "tuv");
            put("9", "wxyz");
        }};

        String currentString = "";
        List<String> totalList = new ArrayList<String>();
        dfs (currentString, totalList, digits, map);
        return totalList;
    }
    
    // HELPER METHOD
    private void dfs (String currentString, List<String> totalList, String digits, Map<String, String> map){
        if (digits.length() == 0) {
            totalList.add(currentString);
            return;
        }
        
        for(int j = 0; j < map.get(String.valueOf(digits.charAt(0))).length(); j++) {
            currentString += map.get(String.valueOf(digits.charAt(0))).charAt(j);
            dfs (currentString, totalList, digits.substring(1), map);
            currentString = currentString.substring(0, currentString.length()-1);
        }
    }
}


************************************************************************************************************
*Problem 18 - 4Sum
*
*Description:Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d 
*	     = target? Find all unique quadruplets in the array which gives the sum of target. 
*	     Note:
*	        Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)
*	     	The solution set must not contain duplicate quadruplets.
*
*	     For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
*
*	        A solution set is:
*	       (-1,  0, 0, 1)
*	       (-2, -1, 1, 2)
*	       (-2,  0, 0, 2)
*
*Parameter: (int[] num, int target)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> fourSum(int[] num, int target) {
        ArrayList<List<Integer>> ans = new ArrayList<>();
        if(num.length<4)return ans;
        Arrays.sort(num);
        for(int i=0; i<num.length-3; i++){
            if(i>0&&num[i]==num[i-1])continue;
            for(int j=i+1; j<num.length-2; j++){
                if(j>i+1&&num[j]==num[j-1])continue;
                int low=j+1, high=num.length-1;
                while(low<high){
                    int sum=num[i]+num[j]+num[low]+num[high];
                    if(sum==target){
                        ans.add(Arrays.asList(num[i], num[j], num[low], num[high]));
                        while(low<high&&num[low]==num[low+1])low++;
                        while(low<high&&num[high]==num[high-1])high--;
                        low++;
                        high--;
                    }
                    else if(sum<target)low++;
                    else high--;
                }
            }
        }
        return ans;
    }
}


************************************************************************************************************
*Problem 19 - Remove Nth Node From End of List 
*
*Description:Given a linked list, remove the nth node from the end of list and return its head. 
*	     For example,
*	     
*	     	Given linked list: 1->2->3->4->5, and n = 2.
*	     	After removing the second node from the end, the linked list becomes 1->2->3->5.
*
*Parameter: (ListNode head, int n)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        ListNode slow = head;
        
        while(n > 0){
            fast = fast.next;
            n--;
        }
        
        if(fast == null){
            head = head.next;
            return head;
        }
        
        while(fast.next != null){ // STOP AT LAST NODE
            fast = fast.next;
            slow = slow.next;
        }
        
        slow.next = slow.next.next;
        return head;
    }
}


************************************************************************************************************
*Problem 20 - Valid Parentheses 
*
*Description:Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the 
*	     input string is valid. 
*	     
*	     The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" 
*	     are not.
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<Character, Character>() {{
            put('(',')');
            put('{','}');
            put('[',']');
        }};
        
        Stack<Character> stack = new Stack<>();
        
        for(char c : s.toCharArray()) {
            if(map.containsKey(c)) {
                stack.push(c);
            } else if(stack.isEmpty() || map.get(stack.pop()) != c) {
                return false;
            }
        }
        return stack.isEmpty();
    }
}


************************************************************************************************************
*Problem 21 - Merge Two Sorted Lists   
*
*Description:Merge two sorted linked lists and return it as a new list.
*	     The new list should be made by splicing together the nodes of the first two lists.
*	     
*
*Parameter: (ListNode l1, ListNode l2)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead; // DEPARTURE FROM DUMMY
        
        while(l1 != null && l2 != null){
            if(l1.val < l2.val){
                cur.next = l1;
                l1 = l1.next;
            } else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        
        if(l1 != null) cur.next = l1;
        if(l2 != null) cur.next = l2;
        
        return dummyHead.next;
    }
}


************************************************************************************************************
*Problem 22 - Generate Parentheses 
*
*Description:Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. 
*	     For example, given n = 3, a solution set is:
*	     "((()))", "(()())", "(())()", "()(())", "()()()"
*	     
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public List<String> generateParenthesis(int n) {
        String currentString = "";
        List<String> totalList = new ArrayList<String>();
        dfs (0, 0, currentString, totalList, n);
        return totalList;
    }
    
    private void dfs (int left, int right, String currentString, List<String> totalList, int n){
        if (left < right){
            return;
        }
        
        if (left > n || right > n){
            return;
        }
        
        if(left == n && right == n){
            totalList.add(currentString);
            return;
        }
        
        for (int i = 0; i <= 1; i++){
            if(i == 0){
                currentString += "(";
                dfs (left + 1, right, currentString, totalList, n);
                currentString = currentString.substring(0, currentString.length()-1);
            } else{
                currentString += ")";
                dfs (left, right + 1, currentString, totalList, n);
                currentString = currentString.substring(0, currentString.length()-1);
            }
        }
    }
}


************************************************************************************************************
*Problem 23 - Merge k Sorted Lists
*
*Description:Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
*	     
*Parameter: (int n)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution1 {
    public static ListNode mergeKLists(ListNode[] lists){
        return partion(lists,0,lists.length-1);
    }

    public static ListNode partion(ListNode[] lists,int s,int e){
        if(s==e)  return lists[s];
        if(s<e){
            int q=(s+e)/2;
            ListNode l1=partion(lists,s,q);
            ListNode l2=partion(lists,q+1,e);
            return merge(l1,l2);
        }else
            return null;
    }

    //This function is from Merge Two Sorted Lists.
    public static ListNode merge(ListNode l1,ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next=merge(l1.next,l2);
            return l1;
        }else{
            l2.next=merge(l1,l2.next);
            return l2;
        }
    }
}


public class Solution2 {
    public ListNode mergeKLists(List<ListNode> lists) {
        if (lists==null||lists.size()==0) return null;

        PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){
            @Override
            public int compare(ListNode o1,ListNode o2){
                if (o1.val<o2.val)
                    return -1;
                else if (o1.val==o2.val)
                    return 0;
                else 
                    return 1;
            }
        });

        ListNode dummy = new ListNode(0);
        ListNode tail=dummy;

        for (ListNode node:lists)
            if (node!=null)
                queue.add(node);

        while (!queue.isEmpty()){
            tail.next=queue.poll();
            tail=tail.next;

            if (tail.next!=null)
                queue.add(tail.next);
        }
        return dummy.next;
    }
}


************************************************************************************************************
*Problem 24 - Swap Nodes in Pairs
*
*Description:Given a linked list, swap every two adjacent nodes and return its head.
*	     For example,
*	     Given 1->2->3->4, you should return the list as 2->1->4->3.
*	     Your algorithm should use only constant space. You may not modify the values in the list, only 
*	     nodes itself can be changed.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy, cur = head;
        
        while(cur != null && cur.next != null){
            prev.next = cur.next; // prev (dummy) points to 2
            cur.next = cur.next.next; // cur points to 3
            prev.next.next = cur; // 2 points to 1
            prev = cur;
            cur = cur.next;
        }
        
        return dummy.next;
    }
}


************************************************************************************************************
*Problem 25 - Reverse Nodes in k-Group
*
*Description:Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
*	     If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
*	     You may not alter the values in the nodes, only nodes itself may be changed.
*	     Only constant memory is allowed. 
*	     For example,
*	     Given this linked list: 1->2->3->4->5
*	     For k = 2, you should return: 2->1->4->3->5
*	     For k = 3, you should return: 3->2->1->4->5
*
*Parameter: (ListNode head, int k)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode begin;
        if (head==null || head.next ==null || k==1) return head;
        ListNode dummyhead = new ListNode(-1);
        dummyhead.next = head;
        begin = dummyhead;
        int i=0;
        while (head != null){
            i++;
            if (i%k == 0){
                begin = reverse(begin, head.next);
                head = begin.next;
            } else {
                head = head.next;
            }
        }
        return dummyhead.next;
    }

    public ListNode reverse(ListNode begin, ListNode end){
        ListNode curr = begin.next;
        ListNode next, first;
        ListNode prev = begin;
        first = curr;
        while (curr!=end){
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        begin.next = prev;
        first.next = curr;
        return first;
    }
}


************************************************************************************************************
*Problem 26 - Remove Duplicates from Sorted Array
*
*Description:Given a sorted array, remove the duplicates in place such that each element appear only once 
*	     and return the new length.
*	     Do not allocate extra space for another array, you must do this in place with constant memory.
*	     For example,
*	     Given input array nums = [1,1,2], 
*	     Your function should return length = 2, with the first two elements of nums being 1 and 2 
*	     respectively. It doesn't matter what you leave beyond the new length.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        
        int i, j = 0;
        for (i = 0; i < nums.length; i++) {
            if (nums[j] != nums[i]) {
		j++;
                nums[j] = nums[i];
            }
        }
        return j + 1;
    }
}


************************************************************************************************************
*Problem 27 - Remove Element 
*
*Description:Given an array and a value, remove all instances of that value in place and return the new length. 
*	     The order of elements can be changed. It doesn't matter what you leave beyond the new length.
*
*Parameter: (int[] nums, int val)
************************************************************************************************************
public class Solution {
    public int removeElement(int[] nums, int val) {
        if (nums == null || nums.length == 0) return 0;
        
        int i, j = 0;
        for (i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[j] = nums[i];
		j++;
            }
        }
        return j;
    }
}


************************************************************************************************************
*Problem 28 - Implement strStr() 
*
*Description:Implement strStr(). 
*	     Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of 
*	     haystack.
*
*Parameter: (String haystack, String needle)
************************************************************************************************************
public class Solution {
    public int strStr(String haystack, String needle) { // haystack.length() > needle.length()
        int m = haystack.length();
        int n = needle.length();
        int i, j; 
        for (i = 0; i <= m - n; i++){
            for (j = 0; j < n; j++) {
                if (haystack.charAt(i+j) != needle.charAt(j)) break;
            }
            if (j == n) return i;
        }
        return -1;
    }
}


************************************************************************************************************
*Problem 29 - Divide Two Integers 
*
*Description:Divide two integers without using multiplication, division and mod operator.
*
*	     If it is overflow, return MAX_INT.
*
*Parameter: (int dividend, int divisor)
************************************************************************************************************
public class Solution {
    public int divide(int dividend, int divisor) {
        long result = divideLong(dividend, divisor);
        return result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;
    }

    public long divideLong(long dividend, long divisor) {
        boolean negative = dividend < 0 != divisor < 0;

        if (dividend < 0) dividend = -dividend;
        if (divisor < 0) divisor = -divisor;

        if (dividend < divisor) return 0;

        long sum = divisor;
        long divide = 1;
        while ((sum+sum) <= dividend) {
            sum += sum;
            divide += divide;
        }

        if(negative)
            return -(divide + divideLong((dividend-sum), divisor));
        else
            return (divide + divideLong((dividend-sum), divisor));
    }
}


************************************************************************************************************
*Problem 31 - Next Permutation 
*
*Description:Implement next permutation, which rearranges numbers into the lexicographically next greater 
*	     permutation of numbers.
*
*	     If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, 
*	     sorted in ascending order).
*
*	     The replacement must be in-place, do not allocate extra memory.
*
*	     Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in 
*	     the right-hand column.
*	     1,2,3 → 1,3,2
*	     3,2,1 → 1,2,3
*	     1,1,5 → 1,5,1
*
*Parameter: (int[] nums)
************************************************************************************************************

************************************************************************************************************
*Problem 33 - Search in Rotated Sorted Array 
*
*Description:Suppose a sorted array is rotated at some pivot unknown to you beforehand.
*	     (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
*	     You are given a target value to search. If found in the array return its index, otherwise return -1.
*	     You may assume no duplicate exists in the array.
*
*Parameter: (int[] nums, int target)
************************************************************************************************************
public class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        
        while(left < right){
            if(right - left == 1) break; // CONVENTION: WHEN LEFT IS NEXT TO RIGHT
            
            int mid = (left + right)/2;
            
            if(nums[left] > nums[right]) { // COMPARE LEFT AND RIGHT, FIRST TYPE OF ROTATED ARRAY
                if(nums[left] < nums[mid]){ // COMPARE LEFT AND MID
                    if(target <= nums[mid] && target >= nums[left]){ // TOWARDS UNROTATED ARRAY
                        right = mid;
                    } else {
                        left = mid;
                    }
                    
                } else { // SECOND TYPE OF ROTATED ARRAY
                    if(target >= nums[mid] && target <= nums[right]){ // TOWARDS UNROTATED ARRAY
                        left = mid;
                    } else {
                        right = mid;
                    }
                }
            } else { // UNROTATED ARRAY
                if(target == nums[mid]){
                  return mid;  
                } if(target < nums[mid]){
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
        }
        
        if(target == nums[left]){
            return left;
        } else if (target == nums[right]){
            return right;
        } else {
            return -1;
        }
    }
}


************************************************************************************************************
*Problem 34 - Search for a Range
*
*Description:Given a sorted array of integers, find the starting and ending position of a given target value. 
*	     Your algorithm's runtime complexity must be in the order of O(log n).
*	     If the target is not found in the array, return [-1, -1].
*
*	     For example,
*	     
*	     Given [5, 7, 7, 8, 8, 10] and target value 8,
*	     return [3, 4].
*
*Parameter: (int[] nums, int target)
************************************************************************************************************
public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int startingIndex = -1, endingIndex = -1;
        int left = 0, right = nums.length - 1;
        
        while (right - left > 1 && nums[left] != target) { // KEEP NARROWING UNTILL LEFT NEXT TO RIGHT
            int mid = (left + right)/2;
            
            if (nums[mid] < target){
                left = mid;
            } else {
                right = mid;
            }
        }
        
        if(nums[left] == target) startingIndex = left; // SPECIAL CASE FOR LEFT
        else if (nums[right] == target) startingIndex = left+1; // NORMAL CASE FOR LEFT
        
        left = 0;
        right = nums.length - 1;
        
        while (right - left > 1 && nums[right] != target) { // KEEP NARROWING UNTILL LEFT NEXT TO RIGHT
            int mid = (left + right)/2;
            
            if (nums[mid] > target){
                right = mid;
            } else {
                left = mid;
            }
        }
        
        if (nums[right] == target) endingIndex = right; // SPECIAL CASE FOR RIGHT
        else if (nums[left] == target) endingIndex = right-1; // NORMAL CASE FOR RIGHT
        
        int[] result = {startingIndex, endingIndex};
        return result;
    }
}


************************************************************************************************************
*Problem 35 - Search Insert Position
*
*Description:Given a sorted array and a target value, return the index if the target is found. If not, return 
*	     the index where it would be if it were inserted in order.
*	     You may assume no duplicates in the array.
*
*	     Here are few examples.
*	     
*	     [1,3,5,6], 5 → 2
*	     [1,3,5,6], 2 → 1
*	     [1,3,5,6], 7 → 4
*	     [1,3,5,6], 0 → 0
*
*Parameter: (int[] nums, int target)
************************************************************************************************************
public class Solution1 {
    public int searchInsert(int[] nums, int target) {
        if (nums[0] > target) return 0;
        if (nums[nums.length-1] < target) return nums.length;
        
        int left = 0, right = nums.length - 1;
        
        while(left < right){
            if(nums[left] == target){
                if(nums[left] > target && nums[left-1] < target){
                    return left - 1;
                } else if(nums[left] < target && nums[left+1] > target){
                    return left + 1;
                }
                break;
            }
            
            int mid = (left + right)/2;
            
            if(nums[mid] < target){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}

public class Solution2 {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        
        while(left < right){
            int mid = (left + right)/2;
            
            if(nums[mid] < target){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return (nums[left] < target) ? left + 1 : left;
    }
}


************************************************************************************************************
*Problem 36 - Valid Sudoku
*
*Description:Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. 
*	     
*	     The Sudoku board could be partially filled, where empty cells are filled with the character '.'.
*
*	     Note:
*
*	     A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need 
*	     to be validated.
*
*Parameter: (char[][] board)
************************************************************************************************************
public class Solution {
    public boolean isValidSudoku(char[][] board) {
        for (int i=0; i<9; i++) {
            if (!isParticallyValid(board,i,0,i,8)) return false;
            if (!isParticallyValid(board,0,i,8,i)) return false;
        }
        for (int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false;
            }
        }
        return true;
    }

    private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2){
        Set singleSet = new HashSet();
        for (int i= x1; i<=x2; i++){
            for (int j=y1;j<=y2; j++){
                if (board[i][j]!='.') 
                    if(!singleSet.add(board[i][j])) return false;
            }
        }
        return true;
    }
}


************************************************************************************************************
*Problem 38 - Count and Say
*
*Description:The count-and-say sequence is the sequence of integers beginning as follows: 
*
*	     1, 11, 21, 1211, 111221, ...
*	     1 is read off as "one 1" or 11.
*	     11 is read off as "two 1s" or 21.
*	     21 is read off as "one 2, then one 1" or 1211.
*	     
*	     Given an integer n, generate the nth sequence.
*	     Note: The sequence of integers will be represented as a string
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public String countAndSay(int n) {
	    if (n <= 0) return null;
 
	    String result = "1";
	    int i = 1;
 
	    while (i < n) {
		    StringBuilder sb = new StringBuilder();
		    int count = 1;
		    for (int j = 1; j < result.length(); j++) {
			    if (result.charAt(j) == result.charAt(j - 1)) {
				    count++;
			    } else {
				    sb.append(count);
				    sb.append(result.charAt(j - 1));
				    count = 1;
			    }
		    }
 
		    sb.append(count);
		    sb.append(result.charAt(result.length() - 1));
		    result = sb.toString();
		    i++;
	    }
 
	    return result;
    }
}


************************************************************************************************************
*Problem 39 - Combination Sum
*
*Description:Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C 
*	     where the candidate numbers sums to T.
*	     The same repeated number may be chosen from C unlimited number of times.
*	     
*	     Note:
*	     1) All numbers (including target) will be positive integers.
*	     2) Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
*	     3) The solution set must not contain duplicate combinations.
*	     
*	     For example, given candidate set 2,3,6,7 and target 7, 
*	     A solution set is: 
*	       [7] 
*	       [2, 2, 3]
*
*Parameter: (int[] candidates, int target)
************************************************************************************************************
public class Solution {
    // DRIVER METHOD
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<Integer> currentList = new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        dfs(0, currentList, totalList, candidates, target);
        return totalList;
    }
    
    // HELPER METHOD
    private void dfs(int index, List<Integer> currentList, List<List<Integer>> totalList, int[] candidates, int target){
        if (target == 0){
            totalList.add(new ArrayList<>(currentList));
            return;
        }
        
        if (target < 0){
            return;
        }
        
        for (int i = index; i < candidates.length; i++){
            currentList.add(candidates[i]);
            dfs(i, currentList, totalList, candidates, target - candidates[i]);
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 40 - Combination Sum II 
*
*Description:Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C 
*	     where the candidate numbers sums to T.
*	     Each number in C may only be used once in the combination.
*	     
*	     Note:
*	     1) All numbers (including target) will be positive integers.
*	     2) Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
*	     3) The solution set must not contain duplicate combinations.
*	     
*	     For example, given candidate set 10,1,2,7,6,1,5 and target 8,
*	     A solution set is: 
*	       [1, 7] 
*	       [1, 2, 5] 
*	       [2, 6] 
*	       [1, 1, 6]
*
*Parameter: (int[] candidates, int target)
************************************************************************************************************
public class Solution {
    // DRIVER METHOD
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<Integer> currentList = new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        dfs(0, currentList, totalList, candidates, target);
        return totalList;
    }
    
    // HELPER METHOD
    private void dfs(int index, List<Integer> currentList, List<List<Integer>> totalList, int[] candidates, int target){
        if (target == 0 && !totalList.contains(currentList)){
            totalList.add(new ArrayList<>(currentList));
            return;
        }
        
        if (target < 0){
            return;
        }
        
        for(int i = index; i < candidates.length; i++){
            currentList.add(candidates[i]);
            dfs(i + 1, currentList, totalList, candidates, target - candidates[i]);
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 41 - First Missing Positive 
*
*Description:Given an unsorted integer array, find the first missing positive integer.
*
*	For example,
*	Given [1,2,0] return 3,
*	and [3,4,-1,1] return 2.
*
*	Your algorithm should run in O(n) time and uses constant space.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int firstMissingPositive(int[] A) {
        int i = 0;
        while(i < A.length){
            if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) 
                i++;
            else if(A[A[i]-1] != A[i]) 
                swap(A, i, A[i]-1);
            else 
                i++;
        }
        i = 0;
        while(i < A.length && A[i] == i+1) i++;
        return i+1;
    }

    private void swap(int[] A, int i, int j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
}


************************************************************************************************************
*Problem 43 - Multiply Strings
*
*Description:Given two numbers represented as strings, return multiplication of the numbers as a string.
*	     
*	     Note: The numbers can be arbitrarily large and are non-negative.
*
*Parameter: (String num1, String num2)
************************************************************************************************************
public class Solution {
    public String multiply(String num1, String num2) {
        String n1 = new StringBuilder(num1).reverse().toString();
        String n2 = new StringBuilder(num2).reverse().toString();
 
        int[] d = new int[num1.length()+num2.length()];
 
        //multiply each digit and sum at the corresponding positions
        for(int i=0; i<n1.length(); i++){
            for(int j=0; j<n2.length(); j++){
                d[i+j] += (n1.charAt(i)-'0') * (n2.charAt(j)-'0');
            }
        }
 
        StringBuilder sb = new StringBuilder();
 
        //calculate each digit
        for(int i=0; i<d.length; i++){
            int mod = d[i]%10;
            int carry = d[i]/10;
            if(i+1<d.length){
                d[i+1] += carry;
            }
            sb.insert(0, mod);
        }
 
        //remove front 0's
        while(sb.charAt(0) == '0' && sb.length()> 1){
            sb.deleteCharAt(0);
        }
 
        return sb.toString();
    }
}


************************************************************************************************************
*Problem 46 - Permutations
*
*Description:Given a collection of numbers, return all possible permutations.
*	     For example,
*	     [1,2,3] have the following permutations:
*	     [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> currentList = new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        List<Integer> numsList = new ArrayList<>();

        for(int i = 0; i < nums.length; i++){
            numsList.add(nums[i]);
        }

        dfs(currentList, totalList, numsList, nums);
        return totalList;
    }
    
    private void dfs(List<Integer> currentList, List<List<Integer>> totalList, List<Integer> numsList, int[] nums){
        if (currentList.size() == nums.length){
            totalList.add(new ArrayList<>(currentList));
            return;
        }
        
        for (int i = 0; i < numsList.size(); i++){
            currentList.add(numsList.get(i));
            numsList.remove(i);
            dfs(currentList, totalList, numsList, nums);
            numsList.add(i, currentList.get(currentList.size() - 1));
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 47 - Permutations II 
*
*Description:Given a collection of numbers that might contain duplicates, return all possible unique permutations.
*	     For example,
*	     [1,1,2] have the following unique permutations:
*	     [1,1,2], [1,2,1], and [2,1,1].
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<Integer> currentList = new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        List<Integer> numsList = new ArrayList<>();

        for(int i = 0; i < nums.length; i++){
            numsList.add(nums[i]);
        }

        dfs(currentList, totalList, numsList, nums);
        return totalList;
    }
    
    private void dfs(List<Integer> currentList, List<List<Integer>> totalList, List<Integer> numsList, int[] nums){
        if (currentList.size() == nums.length){
            totalList.add(new ArrayList<>(currentList));
            return;
        }
        
        for (int i = 0; i < numsList.size(); i++){
            if (i > 0 && numsList.get(i) == numsList.get(i-1)){
                continue;
            }
            currentList.add(numsList.get(i));
            numsList.remove(i);
            dfs(currentList, totalList, numsList, nums);
            numsList.add(i, currentList.get(currentList.size() - 1));
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 48 - Rotate Image
*
*Description:You are given an n x n 2D matrix representing an image.
*	     
*	     Rotate the image by 90 degrees (clockwise).
*
*Parameter: (int[][] matrix)
************************************************************************************************************
public class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int layer = 0;
        while (layer < n/2) {
            int first = layer;
            int last = n - 1 - layer;
            for (int i = first; i < last; ++i) {
                int offset = i - first;
                // SAVE LOOP
                int top = matrix[first][i];
                
                // LEFT -> TOP
                matrix[first][i] = matrix[last-offset][first];
                
                // bottom -> left
                matrix[last-offset][first] = matrix[last][last-offset];
                
                // RIGHT -> BOTTOM
                matrix[last][last-offset] = matrix[i][last];
                
                // TOP -> RIGHT
                matrix[i][last] = top;
            }
            layer++;
        }
    }
}


public class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        for (int i=0; i<n/2; i++) 
            for (int j=i; j<n-i-1; j++) {
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[n-j-1][i];
                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];
                matrix[j][n-i-1]=tmp;
            }
    }
}


************************************************************************************************************
*Problem Amazon OA - Concentric square rotation
*
*Description:You are given an n x n 2D matrix representing an image.
*
*Parameter: (int[][] matrix)
************************************************************************************************************
public class Solution {
    public void rotate(int[][] matrix) {
        int m = matrix.length; // m & n only determine range
        int layer = 0;
        while (layer < m/2) {
            int topRight = matrix[layer][m-1 - layer]; // save top right value
            for (int i = m-1-layer; i > layer; i--) {
                matrix[layer][i] = matrix[layer][i-1];
            }
            
            int bottomRight = matrix[m-1-layer][m-1-layer]; // save bottom right value
            for (int i = m-1-layer; i > layer; i--) {
                matrix[i][m-1-layer] = matrix[i-1][m-1-layer];
            }
            matrix[layer+1][m-1-layer] = topRight; // top right value restored 
            
            int bottomLeft = matrix[m-1-layer][layer]; // save bottom left value
            for (int i = 1+layer; i < m-layer; i++) {
                matrix[m-layer-1][i-1] = matrix[m-layer-1][i];
            }
            matrix[m-layer-1][m-2-layer] = bottomRight; // bottom right value restored. ATTEHTION!
            
            for (int i = 1+layer; i < m-layer; i++) {
                matrix[i-1][layer] = matrix[i][layer];
            }
            matrix[m-1-layer][layer] = bottomLeft; // bottom left value restored
            
            layer++; // increment layer
        }
    }
}


************************************************************************************************************
*Problem 49 - Group Anagrams
*
*Description:Given an array of strings, group anagrams together.
*	     
*	     For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
*	  
*	     Return:
*
*	     [
*	      ["ate", "eat","tea"],
*	      ["nat","tan"],
*	      ["bat"]
*	     ]
*
*	     Note:
*	     
*	     1. For the return value, each inner list's elements must follow the lexicographic order.
*	     2. All inputs will be in lower-case.
*
*Parameter: (String[] strs)
************************************************************************************************************
public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> totalList = new ArrayList<List<String>>();
        Map<String, List<String>> map = new HashMap<>();
        
        for (int i = 0; i < strs.length; i++) {
            char[] tem = strs[i].toCharArray();
            Arrays.sort(tem);
            String s = String.valueOf(tem);
            
            if (!map.containsKey(s)) {
                map.put(s, new ArrayList<>());
            }
            map.get(s).add(strs[i]);
        }
        
        Iterator<List<String>> i = map.values().iterator();
        while (i.hasNext()) {
            List<String> item = i.next();
            Collections.sort(item, (String s1, String s2) -> s1.compareTo(s2));
            totalList.add(item);
        }
        
        return totalList;
    }
}


************************************************************************************************************
*Problem Yahoo
*
*Description:Find the maximum repeating number in O(n) time and O(1) extra space
*
*Parameter: (int[] nums)
************************************************************************************************************
Public Class Solution{
    Public int maxRepeating(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for(int i : nums) {
            if(!map.contains(i))
                map.put(i,1);
	    else
                map.put(i, map.get(i) + 1);
        }
        
        int max = 0;
        Iterator<Integer> iter = map.values().iterator();
        while(iter.hasNext()) {
            max = Math.max(max, iter.next());
        }
        
        return max;
    }
}


************************************************************************************************************
*Problem 50 - Pow(x, n)
*
*Description:Implement pow(x, n).
*
*Parameter: (double x, int n)
************************************************************************************************************
public class Solution {
    public double myPow(double x, int n) {
        if(n == 0)
            return 1;
        if(n<0){
            n = -n;
            x = 1/x;
        }
        if(n%2 == 0) return myPow(x*x, n/2);
        else return x*myPow(x*x, n/2);
    }
}


************************************************************************************************************
*Problem 51 - N-Queens
*
*Description:
*
*Parameter: (int n)
************************************************************************************************************


************************************************************************************************************
*Problem 53 - Maximum Subarray
*
*Description:Find the contiguous subarray within an array (containing at least one number) which has the 
*	     largest sum.
*	     
*	     For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
*	  
*	     the contiguous subarray [4,−1,2,1] has the largest sum = 6.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int maxSubArray(int[] nums) {
        int maxCurrent = nums[0], rst = nums[0];
        for (int i = 1; i < nums.length; i++) {
            maxCurrent = Math.max(maxCurrent + nums[i], nums[i]);
            rst = Math.max(maxCurrent, rst);
        }
        return rst;
    }
}


************************************************************************************************************
*Problem Microsoft - Maximum Product of two integers
*
*Description:
*	     Input: arr[] = {1, 4, 3, 6, 7, 0}  
*            Output: {6,7}  
*
* 	     Input: arr[] = {-1, -3, -4, 2, 0, -5} 
*	     Output: {-4,-5} 
*
*Parameter: (int[] nums)
************************************************************************************************************
The idea is to singly traverse the input array and keep track of following four values.
a) Maximum positive value
b) Second maximum positive value
c) Maximum negative value i.e., a negative value with maximum absolute value
d) Second maximum negative value.
At the end of the loop, compare the products of first two and last two and print the maximum of two products.


************************************************************************************************************
*Problem 54 - Spiral Matrix
*
*Description:Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in 
*	     spiral order.
*	     
*	     For example,
*
*	     Given the following matrix:
*
*	     [
*	      [ 1, 2, 3 ],
*	      [ 4, 5, 6 ],
*	      [ 7, 8, 9 ]
*	     ]
*
*	     You should return [1,2,3,6,9,8,7,4,5].
*
*Parameter: (int[][] matrix)
************************************************************************************************************
public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> elements = new ArrayList<>();
        if (matrix.length == 0) return elements;
        int row = 0, col = -1, m = matrix.length, n = matrix[0].length;
        while (true) {
            for (int i = 0; i < n; i++) elements.add(matrix[row][++col]);
            if (--m == 0) break;
            for (int i = 0; i < m; i++) elements.add(matrix[++row][col]);
            if (--n == 0) break; 
            for (int i = 0; i < n; i++) elements.add(matrix[row][--col]);
            if (--m == 0) break; 
            for (int i = 0; i < m; i++) elements.add(matrix[--row][col]);
            if (--n == 0) break; 
        }
        return elements;
    }
}


************************************************************************************************************
*Problem 55 - Jump Game
*
*Description:Given an array of non-negative integers, you are initially positioned at the first index of the 
*	     array. 
*	     
*	     Each element in the array represents your maximum jump length at that position.
*	     
*	     Determine if you are able to reach the last index.
*	     
*	     For example:
*	     
*	     A = [2,3,1,1,4], return true.
*	     A = [3,2,1,0,4], return false.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public boolean canJump(int[] nums) {
        int reachable = 0;
        for (int i=0; i<nums.length; ++i) {
            if (i > reachable) return false;
            reachable = Math.max(reachable, i + nums[i]);
        }
        return true;
    }
}


************************************************************************************************************
*Problem 56 - Merge Intervals (see 253 meeting room2)
*
*Description:Given a collection of intervals, merge all overlapping intervals. 
*	     
*	     For example:
*	     
*	     Given [1,3],[2,6],[8,10],[15,18],
*	     return [1,6],[8,10],[15,18].
*
*Parameter: (List<Interval> intervals)
************************************************************************************************************
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public List<Interval> merge(List<Interval> intervals) {
        if (intervals == null || intervals.isEmpty())
            return intervals;
        Collections.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval i1, Interval i2) {
                if (i1.start != i2.start) {
                    return i1.start - i2.start;
                }
                return i1.end - i2.end;
            }
        });
        ListIterator<Interval> it = intervals.listIterator();
        Interval cur = it.next();
        while (it.hasNext()) {
            Interval next = it.next();
            if (cur.end < next.start) {
                cur = next;
                continue;
            } else {
                cur.end = Math.max(cur.end, next.end);
                it.remove();
            }
        }
        return intervals;
    }
}


************************************************************************************************************
*Problem 58 - Length of Last Word
*
*Description:Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return 
*	     the length of last word in the string.
*
*	     If the last word does not exist, return 0.
*
*	     Note: A word is defined as a character sequence consists of non-space characters only.
*
*	     For example, 
*	     Given s = "Hello World",
*	     return 5.
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public int lengthOfLastWord(String s) {
        String use = s.trim();
        int count = 0;
        for (int i = use.length() - 1; i >= 0; i--) {
            if (use.charAt(i) != ' ') count++;
            else break;
        }
        return count;
    }
}


************************************************************************************************************
*Problem 59 - Spiral Matrix II
*
*Description:Given an integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order. 
*	     
*	     For example,
*
*	     Given n = 3,
*	     You should return the following matrix:
*
*	     [
*	      [ 1, 2, 3 ],
*	      [ 8, 9, 4 ],
*	      [ 7, 6, 5 ]
*	     ]
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public int[][] generateMatrix(int n) {
        int[][] rst = new int[n][n];
        if (n == 0) return rst;
        int row = 0, col = -1, m = n, count = 0;
        while (true) {
            for (int i = 0; i < n; i++) rst[row][++col] = ++count;
            if (--m == 0) break;
            for (int i = 0; i < m; i++) rst[++row][col] = ++count;
            if (--n == 0) break;
            for (int i = 0; i < n; i++) rst[row][--col] = ++count;
            if (--m == 0) break;
            for (int i = 0; i < m; i++) rst[--row][col] = ++count;
            if (--n == 0) break;
        }
        return rst;
    }
}


************************************************************************************************************
*Problem 60 - Permutation Sequence 
*
*Description:The set [1,2,3,…,n] contains a total of n! unique permutations.
*
*	     By listing and labeling all of the permutations in order,
*	     We get the following sequence (ie, for n = 3):
*
*	     "123"
*	     ”132"
*	     ”213"
*	     ”231"
*	     ”312"
*	     ”321"
*	     Given n and k, return the kth permutation sequence.
*
*	     Note: Given n will be between 1 and 9 inclusive.
*
*Parameter: (ListNode head, int k)
************************************************************************************************************

************************************************************************************************************
*Problem 61 - Rotate List 
*
*Description:Given a list, rotate the list to the right by k places, where k is non-negative.
*	     For example:
*	     Given 1->2->3->4->5->NULL and k = 2,
*	     return 4->5->1->2->3->NULL.
*
*Parameter: (ListNode head, int k)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k%getLen(head) == 0){
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy, slow = dummy; // DEPARTURE FROM DUMMY
        int remaining = k%getLen(head);
        
        while(remaining != 0){ // CONVENTION TO CHECK K-POSITION TO THE RIGHT
            fast = fast.next;
            remaining--;
        }
        
        while(fast.next != null){ // CONVENTION TO CHECK K-POSITION TO THE RIGHT
            fast = fast.next;
            slow = slow.next;
        }
        
        dummy.next = slow.next; // BREAK THE LINK & RE-LINK
        slow.next = null;
        fast.next = head;
        
        return dummy.next;
    }
    
    private int getLen(ListNode node) {
         int len = 0;
         while (node != null) {
             len++;
             node = node.next;
         }
         return len;
     }
}


************************************************************************************************************
*Problem 62 - Unique Paths
*
*Description:A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
*
*	     The robot can only move either down or right at any point in time. The robot is trying to reach 
*	     the bottom-right corner of the grid (marked 'Finish' in the diagram below).
*
*	     How many possible unique paths are there?
*
*Parameter: (int m, int n)
************************************************************************************************************
public class Solution {
    public int uniquePaths(int m, int n) {
        int[][] mat = new int[m + 1][n + 1];
        mat[m - 1][n] = 1;
        for (int r = m - 1; r >= 0; r--) {
            for (int c = n - 1;c >= 0; c--) {
                mat[r][c] = mat[r + 1][c] + mat[r][c + 1];
            }
        }
        return mat[0][0];
    }
}


************************************************************************************************************
*Problem 63 - Unique Paths II
*
*Description:Follow up for "Unique Paths":
*
*	     Now consider if some obstacles are added to the grids. How many unique paths would there be? 
*	     
*	     An obstacle and empty space is marked as 1 and 0 respectively in the grid.
*
*	     For example,
*	   
*	     There is one obstacle in the middle of a 3x3 grid as illustrated below.
*
*	     [
*	      [0,0,0],
*	      [0,1,0],
*	      [0,0,0]
*	     ]
*
*	     The total number of unique paths is 2.
*	     Note: m and n will be at most 100.
*
*Parameter: (int m, int n)
************************************************************************************************************
public class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        if (m == 0) return 0;
        int n = obstacleGrid[0].length;
        int[][] mat = new int[m + 1][n + 1];
        mat[m - 1][n] = 1;
        for (int r = m - 1; r >= 0; r--) {
            for (int c = n - 1; c >= 0; c--) {
                mat[r][c] = (obstacleGrid[r][c] == 1 ? 0 : mat[r][c + 1] + mat[r + 1][c]);
            }
        }
        return mat[0][0];
    }
}


************************************************************************************************************
*Problem 64 - Minimum Path Sum
*
*Description:Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right 
*	     which minimizes the sum of all numbers along its path.
*
*	     Note: You can only move either down or right at any point in time.
*
*Parameter: (int[][] grid)
************************************************************************************************************
public class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int M = grid.length;
        int N = grid[0].length;
        int[][] sum = new int[M][N];

        sum[0][0] = grid[0][0];

        for (int i = 1; i < M; i++) {
            sum[i][0] = sum[i - 1][0] + grid[i][0];
        }

        for (int i = 1; i < N; i++) {
            sum[0][i] = sum[0][i - 1] + grid[0][i];
        }

        for (int i = 1; i < M; i++) {
            for (int j = 1; j < N; j++) {
                sum[i][j] = Math.min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];
            }
        }

        return sum[M - 1][N - 1];
    }
}


************************************************************************************************************
*Problem 66 - Plus One
*
*Description:Given a non-negative number represented as an array of digits, plus one to the number.
*	     The digits are stored such that the most significant digit is at the head of the list.
*
*Parameter: (int[] digits)
************************************************************************************************************
public class Solution {
    public int[] plusOne(int[] digits) {
        int carry = 1; // PLUS ONE
        
        for (int i = digits.length - 1; i >= 0; i--){
            int tem = digits[i];
            
            digits[i] = (carry + digits[i])%10;
            
            carry = (carry + tem >= 10) ? 1 : 0;
        }
        
        if (carry == 1) {
            int [] newArray = new int[digits.length + 1]; // COPY TO NEW ARRAY, SIZE + 1
            newArray[0] = 1;
            for(int i = 0; i < digits.length; i ++) {
                newArray[i+1] = digits[i];
            }
            return newArray;
        }
        return digits;
    }
}


************************************************************************************************************
*Problem 67 - Add Binary
*
*Description:Given two binary strings, return their sum (also a binary string).
*	     For example,
*	     a = "11"
*	     b = "1"
*	     Return "100".
*
*Parameter: (String a, String b)
************************************************************************************************************
public class Solution {
    public String addBinary(String a, String b) {
        if (a==null ||a.length()==0){
            return b;
        }
        
        if (b==null || b.length()==0){
            return a;
        }
        
        StringBuilder sb=new StringBuilder();
       
        int lastA=a.length()-1;
        int lastB=b.length()-1;
        int carry=0;
        
        while (lastA>=0 ||lastB>=0 ||carry>0){
            int num1=lastA>=0?a.charAt(lastA--)-'0':0; // WHICH STRING IS LONGER
            int num2=lastB>=0?b.charAt(lastB--)-'0':0;
            int current=(num1+num2+carry)%2;
            carry=(num1+num2+carry)/2;
            
            sb.insert(0, current);
        }
        
        return sb.toString();
    }
}


************************************************************************************************************
*Problem 69 - Sqrt(x)
*
*Description:Implement int sqrt(int x).
*	     Compute and return the square root of x.
*
*Parameter: (int x)
************************************************************************************************************
public class Solution {
    public int mySqrt(int x) {
        if (x == 0) return 0;
        int left = 1, right = Integer.MAX_VALUE;
        while (true) {
            int mid = left + (right - left)/2;
            if (mid > x/mid) {
                right = mid - 1;
            } else {
                if (mid + 1 > x/(mid + 1))
                    return mid;
                left = mid + 1;
            }
        }
    }
}


************************************************************************************************************
*Problem 70 - Climbing Stairs
*
*Description:You are climbing a stair case. It takes n steps to reach to the top.
*	     
*	     Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) return 1;
        int p = 1, q = 2;
        for (int i = 3; i <= n; i++){
            int temp = q;
            q += p;
            p = temp;
        }
        return q;
    }
}


************************************************************************************************************
*Problem 71 - Simplify Path
*
*Description:Given an absolute path for a file (Unix-style), simplify it.
*
*	     For example,
*	     path = "/home/", => "/home"
*	     path = "/a/./b/../../c/", => "/c"
*
*Parameter: (String path)
************************************************************************************************************
public class Solution {
    public String simplifyPath(String path) {
        String result = "/";
        String[] stubs = path.split("/+");
        ArrayList<String> paths = new ArrayList<String>();
        for (String s : stubs){
            if(s.equals("..")){
                if(paths.size() > 0){
                    paths.remove(paths.size() - 1);
                }
            }
            else if (!s.equals(".") && !s.equals("")){
                paths.add(s);
            }
        }
        for (String s : paths){
            result += s + "/";
        }
        if (result.length() > 1)
            result = result.substring(0, result.length() - 1);
        return result;
    }
}


************************************************************************************************************
*Problem 72 - Edit Distance
*
*Description:Given two words word1 and word2, find the minimum number of steps required to convert word1 to 
*	     word2. (each operation is counted as 1 step.)
*	     
*	     You have the following 3 operations permitted on a word:
*	     a) Insert a character
*	     b) Delete a character
*	     c) Replace a character
*
*Parameter: (String word1, String word2)
************************************************************************************************************
public class Solution {
    public int minDistance(String word1, String word2) {
        if (word1.equals(word2)) return 0;
        
        if (word1.length() == 0 || word2.length() == 0) return Math.abs(word1.length() - word2.length());
    
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];

        for (int i = 0; i <= word1.length(); i++) 
	    dp[i][0] = i;
        for (int i = 0; i <= word2.length(); i++) 
	    dp[0][i] = i;
    
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
}


************************************************************************************************************
*Problem 73 - Set Matrix Zeroes 
*
*Description:Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.
*
*Parameter: (int[][] matrix)
************************************************************************************************************
public class Solution {
    public void setZeroes(int[][] matrix) {
        boolean[] row = new boolean[matrix.length];
        boolean[] col = new boolean[matrix[0].length];
        
        // STORE THE ROW AND COLUMN INDEX WITH VALUE 0
        for (int i = 0; i < matrix.length; i++) { 
           for (int j = 0; j < matrix[0].length; j++) {
               if (matrix[i][j] == 0) {
                   row[i] = true;
                   col[j] = true;
               }
           } 
        }
        
        // NULLIFY ROWS
        for (int i = 0; i < row.length; i++) {
            if (row[i]) nullifyRow(matrix, i);
        }
        
        // NULLIFY COLUMNS
        for (int j = 0; j < col.length; j++) {
            if (col[j]) nullifyCol(matrix, j);
        }
    }
    
    private void nullifyRow(int[][] matrix, int row) {
        for (int j = 0; j < matrix[0].length; j++) {
            matrix[row][j] = 0;
        }
    }
    
    private void nullifyCol(int[][] matrix, int col) {
        for (int j = 0; j < matrix.length; j++) {
            matrix[j][col] = 0;
        }
    }
}


************************************************************************************************************
*Problem 74 - Search a 2D Matrix
*
*Description:Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the 
*	     following properties:
*	     	Integers in each row are sorted from left to right.
*	     	The first integer of each row is greater than the last integer of the previous row.
*	     For example,
*	     Consider the following matrix:
*	     [
*	       [1,   3,  5,  7],
*	       [10, 11, 16, 20],
*	       [23, 30, 34, 50]
*	     ]
*
*Parameter: (int[][] matrix, int target)
************************************************************************************************************
public class Solution1 {
    public boolean searchMatrix(int[][] matrix, int target) {
        int start = 0, end = matrix.length - 1;
        
        while (start < end && end - start > 1) { // SEARCH VERTICALLY
            int mid = (start + end)/2;
            
            if(matrix[mid][0] < target){
                start = mid;
            } else {
                end = mid;
            }
        }
        
        int startingRow = -1;
        
        if(matrix[end][0] <= target) { // CHECK WHICH ROW AS BASE ROW
            startingRow = end;
        } else {
            startingRow = start;
        }
        
        start = 0; // RESET START AND END
        end = matrix[startingRow].length - 1; 
        
        while (start < end && end - start > 1) { // SEARCH HORIZONTALLY
            int mid = (start + end)/2;
            
            if(matrix[startingRow][mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        
        if(matrix[startingRow][start] == target || matrix[startingRow][end] == target) {
            return true;
        } else {
            return false;
        }
    }
}


public class Solution2 {
    public boolean searchMatrix(int[][] matrix, int target) {
        int row_num = matrix.length;
        int col_num = matrix[0].length;

        int begin = 0, end = row_num * col_num - 1;

        while(begin <= end){
            int mid = (begin + end) / 2;
            int mid_value = matrix[mid/col_num][mid%col_num];

            if( mid_value == target){
                return true;
            }else if(mid_value < target){
                //Should move a bit further, otherwise dead loop.
                begin = mid+1;
            }else{
                end = mid-1;
            }
        }
    return false;
    }
}


************************************************************************************************************
*Problem 75 - Sort Colors
*
*Description:Given an array with n objects colored red, white or blue, sort them so that objects of the same
*	     color are adjacent, with the colors in the order red, white and blue.
*	     
*	     Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue 
*	     respectively.
*	     	
*	     Note:
*	     You are not suppose to use the library's sort function for this problem.
*
*Parameter: (int[][] matrix, int target)
************************************************************************************************************
public class Solution {
    public void sortColors(int[] nums) {
        // 1-pass
        int p1 = 0, p2 = nums.length - 1, index = 0;
        while (index <= p2) {
            if (nums[index] == 0) {
                nums[index] = nums[p1];
                nums[p1] = 0;
                p1++;
            }
            if (nums[index] == 2) {
                nums[index] = nums[p2];
                nums[p2] = 2;
                p2--;
                index--;
            }
            index++;
        }
    }
}

public class Solution {
    public void sortColors(int[] nums) {
        // 2-pass
        int count0 = 0, count1 = 0, count2 = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {count0++;}
            if (nums[i] == 1) {count1++;}
            if (nums[i] == 2) {count2++;}
        }
        for(int i = 0; i < nums.length; i++) {
            if (i < count0) {nums[i] = 0;}
            else if (i < count0 + count1) {nums[i] = 1;}
            else {nums[i] = 2;}
        }
    }
}


************************************************************************************************************
*Problem 76 - Minimum Window Substring
*
*Description:Given a string S and a string T, find the minimum window in S which will contain all the characters 
*	     in T in complexity O(n).
*
*	     For example,
*		S = "ADOBECODEBANC"
*		T = "ABC"
*		Minimum window is "BANC".
*
*	     Note:
*		If there is no such window in S that covers all characters in T, return the empty string "".
*
*		If there are multiple such windows, you are guaranteed that there will always be only one 
*		unique minimum *window in S.
*
*Parameter: (String s, String t)
************************************************************************************************************
public class Solution {
    public String minWindow(String S, String T) {
        if(S==null||S.isEmpty()||T==null||T.isEmpty()) return "";
        int i=0, j=0;
        
        int[] Tmap=new int[256];
        int[] Smap=new int[256];
        
        for(int k=0; k< T.length(); k++)
            Tmap[T.charAt(k)]++;

        int found=0;
        int length=Integer.MAX_VALUE;
        String res="";
        
        while(j<S.length()){
            if(found<T.length()){
                if(Tmap[S.charAt(j)]>0){
                    Smap[S.charAt(j)]++;
                    if(Smap[S.charAt(j)]<=Tmap[S.charAt(j)])
                        found++;
                }
                j++;
            }
            while(found==T.length()){
                if(j-i<length){
                    length=j-i; res=S.substring(i,j);
                }
                if(Tmap[S.charAt(i)]>0){
                    Smap[S.charAt(i)]--;
                    if(Smap[S.charAt(i)]<Tmap[S.charAt(i)])
                        found--;
                }
                i++;
            }
        }
        return res;
    }
}


************************************************************************************************************
*Problem 77 - Combinations
*
*Description:Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
*	     For example,
*	     If n = 4 and k = 2, a solution is:
*	     [
*	       [2,4],
*	       [3,4],
*	       [2,3],
*	       [1,2],
*	       [1,3],
*              [1,4],
*	     ]
*
*Parameter: (int n, int k)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<Integer> currentList = new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();

        dfs(0, currentList, totalList, n, k);
        return totalList;
    }
    
    private void dfs(int index, List<Integer> currentList, List<List<Integer>> totalList, int n, int k){
        if  (currentList.size() == k ){
            totalList.add(new ArrayList<Integer>(currentList));
            return;
        }
        
        for (int i = index; i < n; i++){
            currentList.add(i+1);
            dfs(i+1, currentList, totalList, n, k);
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 78 - Subsets 
*
*Description:Given a set of distinct integers, nums, return all possible subsets.
*	     
*	     Note:
*	     	Elements in a subset must be in non-descending order.
*	       	The solution set must not contain duplicate subsets.
*	       
*	     For example,
*	       	If nums = [1,2,3], a solution is:
*	       
*              [
*	         [3],
*  		 [1],
*  		 [2],
*  		 [1,2,3],
*  		 [1,3],
*  		 [2,3],dsdsa
*  		 [1,2],
*  		 []
*	       ]
*	     
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        Arrays.sort(nums);
        List<Integer> currentList =  new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        
        dfs(0, currentList, totalList, nums);
        totalList.add(new ArrayList<>());
        return totalList;
    }
    
    private void dfs(int index, List<Integer> currentList, List<List<Integer>> totalList, int[] nums){
        // if (index == nums.length){
        //     return;
        // }
        
        for (int i = index; i < nums.length; i++){
            currentList.add(nums[i]);
            totalList.add(new ArrayList<>(currentList));
            dfs(i + 1, currentList, totalList, nums);
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 79 - Word Search
*
*Description:Given a 2D board and a word, find if the word exists in the grid.
*	     The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells 
*	     are those horizontally or vertically neighboring. The same letter cell may not be used more than 
*	     once.
*	       
*	     For example,
*	     Given board =
*	       
*              [
*	         ["ABCE"],
*  		 ["SFCS"],
*  		 ["ADEE"]
*	       ]
*	     
*	     word = "ABCCED", -> returns true,
*	     word = "SEE", -> returns true,
*	     word = "ABCB", -> returns false.
*
*Parameter: (char[][] board, String word)
************************************************************************************************************
public class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;
 
        boolean result = false;
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(dfs(board,word,i,j,0)){
                    result = true;
                }
            }
        }
 
        return result;
    }
 
    private boolean dfs(char[][] board, String word, int i, int j, int k){
        int m = board.length;
        int n = board[0].length;
 
        if(i<0 || j<0 || i>=m || j>=n) return false;
 
        if(board[i][j] == word.charAt(k)){
            char temp = board[i][j];
            board[i][j]='#';
            if(k==word.length()-1){
                return true;
            } else if (dfs(board, word, i-1, j, k+1)
                        ||dfs(board, word, i+1, j, k+1)
                        ||dfs(board, word, i, j-1, k+1)
                        ||dfs(board, word, i, j+1, k+1)){
                return true;
            }
            board[i][j]=temp;
        }
 
        return false;
    }
}


************************************************************************************************************
*Problem 80 - Remove Duplicates from Sorted Array II
*
*Description:Follow up for "Remove Duplicates":
*	     What if duplicates are allowed at most twice? 
*	       
*	     For example,
*	     Given sorted array nums = [1,1,1,2,2,3],
*	       
*            Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 
*	     and 3. It doesn't matter what you leave beyond the new length.
*
*Parameter: (char[][] board, String word)
************************************************************************************************************
public class Solution {
    public int removeDuplicates(int[] nums) {
        return removeDuplicates(nums, 2);
    }

    public int removeDuplicates(int[] nums, int k) {
        int len = nums.length, count = 1;

        int j = 1;
        for (int i = 1; i < nums.length; i++) {
            count = (nums[i] != nums[i-1]) ? 1 : count+1;
            if ( count > k ) {
                len--;
            } else {
                nums[j] = nums[i];
                j++;
            }
        }
        
        return len;
    }
}


************************************************************************************************************
*Problem 81 - Search in Rotated Sorted Array 
*
*Description:Follow up for "Search in Rotated Sorted Array":
*	     What if duplicates are allowed?
*	     Would this affect the run-time complexity? How and why?
*	     Write a function to determine if a given target is in the array.
*
*Parameter: (int[] nums, int target)
************************************************************************************************************
public class Solution {
    public boolean search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        
        while(left < right){
            if(right - left == 1) break; // CONVENTION: WHEN LEFT IS NEXT TO RIGHT
            
            int mid = (left + right)/2;
            
            if(nums[left] >= nums[right]) { // COMPARE LEFT AND RIGHT, FIRST TYPE OF ROTATED ARRAY
                if (nums[left] == nums[mid]){ // THINK: [1,3,1,1] && [1,1,3,1]
                    left++;
                } else if(nums[left] < nums[mid]){ // COMPARE LEFT AND MID
                    if(target <= nums[mid] && target >= nums[left]){ // TOWARDS UNROTATED ARRAY
                        right = mid;
                    } else {
                        left = mid;
                    }
                    
                } else { // SECOND TYPE OF ROTATED ARRAY
                    if(target >= nums[mid] && target <= nums[right]){ // TOWARDS UNROTATED ARRAY
                        left = mid;
                    } else {
                        right = mid;
                    }
                }
            } else { // UNROTATED ARRAY
                if(target == nums[mid]){
                  return true;  
                } if(target < nums[mid]){
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
        }
        
        if(target == nums[left] || target == nums[right]){
            return true;
        } else {
            return false;
        }
    }
}


************************************************************************************************************
*Problem 82 - Remove Duplicates from Sorted List II 
*
*Description:Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct 
*	     numbers from the original list.
*	     For example,
*            Given 1->2->3->3->4->4->5, return 1->2->5.
*	     Given 1->1->1->2->3, return 2->3.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode slow = dummy, fast = head;
        
        if(fast.val != fast.next.val) { // SPECIAL CASE: CHECK 1ST AND 2ND NODE
            slow.next = fast;
            slow = slow.next;
        }
        
        while(fast.next.next != null) {
            if(fast.val != fast.next.val && fast.next.val != fast.next.next.val) { // CHECK EVERY 3 ELEMENTS
                slow.next = fast.next; // ASSIGN FAST.NEXT TO SLOW
                slow = slow.next;
            } 
            fast = fast.next; // ADVANCE FAST ONE ELEMENT
        }
        
        if(fast.val != fast.next.val) { // SPECIAL CASE: CHECK LAST 2 ELEMENTS
            slow.next = fast.next;
        } else {
            slow.next = null;
        }

        return dummy.next;
    }
}


public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null) return null;
        
        ListNode dummy = new ListNode(0);
        dummy.next=head;
        
        ListNode pre = dummy, cur=head;
        
        while(cur!=null){
            while(cur.next != null && cur.val == cur.next.val){
                cur=cur.next;
            }
            if(pre.next == cur){
                pre=pre.next;
            } else{
                pre.next=cur.next;
            }
            cur=cur.next;
        }

        return dummy.next;
    }
}


************************************************************************************************************
*Problem Apple - Remove Consective String 
*
*Description:Given a string
*
*            Given azxxzy, return ay
*	     Given abbc, return ac
*	     Given acaaabbbacdddd, return acac
*	     Given abbabb, return “”
*
*
*Parameter: (String s)
************************************************************************************************************
public class RemoveConsectiveString {
    public static String remove(String s) {
        StringBuilder sb = new StringBuilder(s);
        return eliminate(sb);   
    }
    
    private static String eliminate(StringBuilder sb) {
        StringBuilder nsb = new StringBuilder();
        
        sb.insert(0, " ");
        sb.append(" ");
        
        for(int i = 1; i < sb.length()-1; i++) {
            if(sb.charAt(i-1) != sb.charAt(i) && sb.charAt(i) != sb.charAt(i+1))
                nsb.append(sb.charAt(i));
        }
        
        sb.deleteCharAt(0);
        sb.deleteCharAt(sb.length()-1);
        
        if(sb.toString().equals(nsb.toString()))
            return sb.toString();
        
        return(eliminate(nsb));
    }
    
    public static void main(String[] args) {
        String s1 = "abbc", s2 = "acccbddd", s3 = "aa", s4 = "", s5 = "acaaabbbacdddd";
        System.out.println(remove(s1));
        System.out.println(remove(s2));
        System.out.println(remove(s3));
        System.out.println(remove(s4));
        System.out.println(remove(s5));
    }
}


************************************************************************************************************
*Problem 83 - Remove Duplicates from Sorted List 
*
*Description:Given a sorted linked list, delete all duplicates such that each element appear only once.
*	     For example,
*            Given 1->1->2, return 1->2.
*	     Given 1->1->2->3->3, return 1->2->3.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null || head.next == null) return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode nodePtr = head; // DEPARTURE FROM head, SEE Problem 203
        
        while(nodePtr.next != null) {
            if(nodePtr.val == nodePtr.next.val){
                nodePtr.next = nodePtr.next.next;
            } else {
                nodePtr = nodePtr.next; // UPDATE
            }
        }
        return dummy.next;
    }
}


************************************************************************************************************
*Problem 85 - Maximal Rectangle
*
*Description:Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all 
*	     ones and return its area.
*
*Parameter: (char[][] matrix)
************************************************************************************************************

************************************************************************************************************
*Problem 86 - Partition List
*
*Description:Given a linked list and a value x, partition it such that all nodes less than x come before 
*	     nodes greater than or equal to x.
*            You should preserve the original relative order of the nodes in each of the two partitions.
*	     For example,
*	     Given 1->4->3->2->5->2 and x = 3,
*	     return 1->2->2->4->3->5.
*
*Parameter: (ListNode head, int x)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode partition(ListNode head, int x) {
        if(head == null) return null;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode fast = dummy;
        ListNode slow = dummy;
        
        while(fast.next != null){
            if(fast.next.val >= x){
                fast = fast.next; // ADVANCE FAST
            } else{
                if(fast != slow){
                    ListNode slowNext = slow.next;
                    ListNode fastNext = fast.next.next;
                    slow.next = fast.next; // STEP NO.1: BUILD RELATION OF SLOW
                    fast.next.next = slowNext; // STEP NO.2: BUILD RELATION OF FAST.NEXT
                    fast.next = fastNext; // STEP NO.3: BUILD RELATION OF FAST
                
                    slow = slow.next; // ONLY ADVANCE SLOW
                } else{ // SPECIAL CASE: WHEN FAST AND SLOW ARE THE SAME
                    fast = fast.next;
                    slow = slow.next;
                }
            }
        }

        return dummy.next;
    }
}


************************************************************************************************************
*Problem 88 - Merge Sorted Array
*
*Description:Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. 
*	     Note:
*            You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold 
*	     additional elements from nums2. The number of elements initialized in nums1 and nums2 are m 
*	     and n respectively.
*
*Parameter: (int[] nums1, int m, int[] nums2, int n)
************************************************************************************************************
public class Solution {
    public void merge(int[] a, int m, int[] b, int n) {
        int i=m-1;
        int j=n-1;
        int k = m+n-1;
        while(i >=0 && j>=0) {
            if(a[i] > b[j])
                a[k--] = a[i--];
            else
                a[k--] = b[j--];
        }
        while(j>=0)
            a[k--] = b[j--];
    }
}


************************************************************************************************************
*Problem 89 - Gray Code 
*
*Description:The gray code is a binary numeral system where two successive values differ in only one bit.
*	     Given a non-negative integer n representing the total number of bits in the code, print the 
*	     sequence of gray code. A gray code sequence must begin with 0.
*	     
*	       
*	     For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
*	       	00 - 0
*	        01 - 1
*               11 - 3
*	        10 - 2
*  		 
*  	     Note:
*  		 For a given n, a gray code sequence is not uniquely defined.
*  		 For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.
*  		 For now, the judge is able to judge based on one instance of gray code sequence. Sorry about 
*	         that.
*	     
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ret= new ArrayList<Integer>();
        int size=1<<n;
        for(int i=0;i<size;i++){
            ret.add(i^(i>>1));
        }
        return ret;
    }
}


************************************************************************************************************
*Problem 90 - Subsets II 
*
*Description:Given a collection of integers that might contain duplicates, nums, return all possible subsets.
*	     
*	     Note:
*	     	Elements in a subset must be in non-descending order.
*	       	The solution set must not contain duplicate subsets.
*	       
*	     For example,
*	       	If nums = [1,2,2], a solution is:
*	       
*              [
*  		 [2],
*  		 [1],
*  		 [1,2,2],
*  		 [2,2],
*  		 [1,2],
*  		 []
*	       ]
*	     
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<Integer> currentList =  new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        
        dfs(0, currentList, totalList, nums);
        totalList.add(new ArrayList<>());
        return totalList;
    }
    
    private void dfs(int index, List<Integer> currentList, List<List<Integer>> totalList, int[] nums){
        for (int i = index; i < nums.length; i++){

            if (i > index && nums[i] == nums[i-1]){
                continue;
            }
            
            currentList.add(nums[i]);
            totalList.add(new ArrayList<>(currentList));
            dfs(i + 1, currentList, totalList, nums);
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 91 - Decode Ways
*
*Description:A message containing letters from A-Z is being encoded to numbers using the following mapping:
*
*	     'A' -> 1
*	     'B' -> 2
*	     ...
*	     'Z' -> 26
*	     
*	     Given an encoded message containing digits, determine the total number of ways to decode it.
*	     
*	     For example,
*
*	     Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).
*	     The number of ways decoding "12" is 2.
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {  
    public int numDecodings(String s) {  
        if(s==null || s.length()==0) {  
            return 0;  
        }  
        if(s.charAt(0)=='0') {  
            return 0;  
        }  
          
        int [] number = new int[s.length() + 1];  
        number[0] = 1;  
        number[1] = 1;  
        int tmp;  
        for(int i=2;i<=s.length();i++) {  
            //检查当前字符是不是'0'  
            tmp = Integer.parseInt(s.substring(i-1,i));  
            if(tmp!=0) {              
                number[i] = number[i-1];  
            }  
            //检查当前字符和前一个字符组合在一起是否在1-26之间  
            if(s.charAt(i-2)!='0') {  
                tmp = Integer.parseInt(s.substring(i-2,i));  
                if(tmp>0&&tmp<=26) {  
                    number[i] += number[i-2];  
                }  
            }  
        }  
        return number[s.length()];  
    }  
}  


************************************************************************************************************
*Problem 92 - Reverse Linked List II
*
*Description:Reverse a linked list from position m to n. Do it in-place and in one-pass.
*
*	     For example: 
*	     Given 1->2->3->4->5->NULL, m = 2 and n = 4,
*	     return 1->4->3->2->5->NULL.
*
*	     Note:
*	     Given m, n satisfy the following condition:
*	     1 ≤ m ≤ n ≤ length of list.
*
*Parameter: (ListNode head, int m, int n)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(head == null || head.next == null || m == n){
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy, slow = dummy; // DEPARTURE FROM DUMMY
        int len = n - m;
        
        while(len != 0){ // CONVENTION: CHECK K-POSITION TO THE RIGHT
            fast = fast.next;
            len--;
        }
        
        while(m != 1){ // CONVENTION: CHECK K-POSITION TO THE RIGHT
            slow = slow.next;
            fast = fast.next;
            m--;
        }
        
        ListNode reservedNode = fast.next.next; // YOU HAVE TO UNDERSTAND REF OF FAST
        fast.next.next = null; // CUT LINK OF RIGHT PART
        slow.next = reverseList(slow.next); // NO NEED TO CUT LINK OF LEFT PART BEFORE REVERSING
        
        while(slow.next != null){
            slow = slow.next;
        }
        
        slow.next = reservedNode; // LINK THE RIGHT PART
        
        return dummy.next;
    }
    
    private ListNode reverseList(ListNode head) {
        if(head == null){
            return head;
        }
        
        ListNode prev = null;
        ListNode cur = head;
        
        while(cur != null){
            ListNode originalNext = cur.next;
            cur.next = prev;
            prev = cur;
            cur = originalNext;
        }
        return prev;
    }
}


************************************************************************************************************
*Problem 93 - Restore IP Addresses
*
*Description:Given a string containing only digits, restore it by returning all possible valid IP address combinations.
*
*	     For example: 
*	     Given "25525511135",
*	     return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public List<String> restoreIpAddresses(String s) {
        ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();
        ArrayList<String> t = new ArrayList<String>();
        dfs(result, s, 0, t);
 
        ArrayList<String> finalResult = new ArrayList<String>();
 
        for(ArrayList<String> l: result){
            StringBuilder sb = new StringBuilder();
            for(String str: l){
                sb.append(str+".");
            }
            sb.setLength(sb.length() - 1);
            finalResult.add(sb.toString());
        }
 
        return finalResult;
    }
 
    private void dfs(ArrayList<ArrayList<String>> result, String s, int start, ArrayList<String> t){
        //if already get 4 numbers, but s is not consumed, return
        if(t.size()>=4 && start!=s.length()) return;
 
        //make sure t's size + remaining string's length >=4
        if((t.size()+s.length()-start+1)<4) return;
 
        //t's size is 4 and no remaining part that is not consumed.
        if(t.size()==4 && start==s.length()){
            ArrayList<String> temp = new ArrayList<String>(t);
            result.add(temp);
            return;
        }
 
        for(int i=1; i<=3; i++){
            //make sure the index is within the boundary
            if(start+i>s.length()) break;
 
            String sub = s.substring(start, start+i);
            //handle case like 001. i.e., if length > 1 and first char is 0, ignore the case.
            if(i>1 && s.charAt(start)=='0'){
                break;    
            }
 
            //make sure each number <= 255
            if(Integer.valueOf(sub)>255) break;
 
            t.add(sub);
            dfs(result, s, start+i, t);
            t.remove(t.size()-1);
        }
    }
}


************************************************************************************************************
*Problem 94 - Binary Tree Inorder Traversal
*
*Description:Given a binary tree, return the inorder traversal of its nodes' values. (See website)
*
*Parameter: (TreeNode root)
************************************************************************************************************



************************************************************************************************************
*Problem 95 - Unique Binary Search Trees II
*
*Description:Given n, how many structurally unique BST's (binary search trees) that store values 1...n?
*
*	     For example,
*	     Given n = 3, there are a total of 5 unique BST's.
*		1         3     3      2      1
*	         \       /     /      / \      \
*	          3     2     1      1   3      2
*	         /     /       \                 \
*	        2     1         2                 3
*
*Parameter: (int n)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<TreeNode> generateTrees(int n) {
        return generateTrees(1, n);
    }
 
    public List<TreeNode> generateTrees(int start, int end) {
        List<TreeNode> list = new LinkedList<>();
 
        if (start > end) {
            list.add(null);
            return list;
        }
 
        for (int i = start; i <= end; i++) {
            List<TreeNode> lefts = generateTrees(start, i - 1);
            List<TreeNode> rights = generateTrees(i + 1, end);
            for (TreeNode left : lefts) {
                for (TreeNode right : rights) {
                    TreeNode node = new TreeNode(i);
                    node.left = left;
                    node.right = right;
                    list.add(node);
                }
            }
        }
        return list;
    }
}


************************************************************************************************************
*Problem 96 - Unique Binary Search Trees
*
*Description:Given n, how many structurally unique BST's (binary search trees) that store values 1...n?
*
*	     For example,
*	     Given n = 3, there are a total of 5 unique BST's.
*		1         3     3      2      1
*	         \       /     /      / \      \
*	          3     2     1      1   3      2
*	         /     /       \                 \
*	        2     1         2                 3
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
/**
 * The case for 3 elements example
 * Count[3] = Count[0]*Count[2] (1 as root) + Count[1]*Count[1] (2 as root) + Count[2]*Count[0] (3 as root)
 * Therefore, we can get the equation:
 * Count[i] = ∑ Count[0...k] * [ k+1....i]     0<=k<i-1  
 */
    public int numTrees(int n) {
        int[] count = new int[n+2];
        count[0] = 1;
        count[1] = 1;
        
        for(int i=2;  i<= n; i++){
            for(int j=0; j<i; j++){
                count[i] += count[j] * count[i - j - 1];
            }
        }
        return count[n];
    }
}


************************************************************************************************************
*Problem 97 - Interleaving String
*
*Description:Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.
*
*	For example,
*	Given:
*	s1 = "aabcc",
*	s2 = "dbbca",
*
*	When s3 = "aadbbcbcac", return true.
*	When s3 = "aadbbbaccc", return false.
*
*Parameter: (String s1, String s2, String s3)
************************************************************************************************************
public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if ((s1.length()+s2.length())!=s3.length()) return false;
        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];

        matrix[0][0] = true;

        for (int i = 1; i < matrix[0].length; i++)
            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));

        for (int i = 1; i < matrix.length; i++)
            matrix[i][0] = matrix[i-1][0]&&(s2.charAt(i-1)==s3.charAt(i-1));

        for (int i = 1; i < matrix.length; i++){
            for (int j = 1; j < matrix[0].length; j++){
                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))
                    || (matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));
            }
        }
        return matrix[s2.length()][s1.length()];
    }
}


************************************************************************************************************
*Problem 98 - Validate Binary Search Tree
*
*Description:Given a binary tree, determine if it is a valid binary search tree (BST).
*
*	     Assume a BST is defined as follows:
*		The left subtree of a node contains only nodes with keys less than the node's key.
*		The right subtree of a node contains only nodes with keys greater than the node's key.
*		Both the left and right subtrees must also be binary search trees.
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isValidBST(TreeNode root) {
        return valid(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);    
    }
 
    private boolean valid(TreeNode p, double min, double max){
        if(p==null) return true;
 
        if(p.val <= min || p.val >= max) return false;
 
        return valid(p.left, min, p.val) && valid(p.right, p.val, max);
    }
}


************************************************************************************************************
*Problem 100 - Same Tree
*
*Description:Given two binary trees, write a function to check if they are equal or not. 
*	     Two binary trees are considered equal if they are structurally identical and the nodes have the 
*	     same value.
*
*Parameter: (TreeNode p, TreeNode q)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p == null || q == null) return false;
        if(p.val == q.val)
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        return false;
    }
}


************************************************************************************************************
*Problem 101 - Symmetric Tree
*
*Description:Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root==null || isSymmetricHelp(root.left, root.right);
    }

    private boolean isSymmetricHelp(TreeNode left, TreeNode right){
        if(left==null || right==null)
            return left==right;
        if(left.val!=right.val)
            return false;
        return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);
    }
}


************************************************************************************************************
*Problem 102 - Binary Tree Level Order Traversal
*
*Description:Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to 
*	     right, level by level). (See website)
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void levelOrderPrint(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
        }
    }
}


public class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        if(root == null) return totalList;
        Queue<TreeNode> current_layer = new LinkedList<>();
        current_layer.add(root);         
        
        while(!current_layer.isEmpty()){
            Queue<TreeNode> next_layer = new LinkedList<>();
            List<Integer> nowList = new ArrayList<>();
            
            while(!current_layer.isEmpty()){
                TreeNode node = current_layer.poll();
                nowList.add(node.val);
                if(node.left!=null)
                    next_layer.add(node.left);
                if(node.right!=null)
                    next_layer.add(node.right);                
            }

            totalList.add(nowList);
            current_layer = next_layer; // TIME TO SWITCH TO NEXT QUEUE
        }

        return totalList;
    }
}


************************************************************************************************************
*Problem 103 - Binary Tree Zigzag Level Order Traversal
*
*Description:Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from 
*	     left to right, then right to left for the next level and alternate between). 
*	     
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if(root==null) return result;
        int toRight = 1;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);

        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> list = new ArrayList<>();

            for(int i=0;i<size;i++){
                TreeNode node = q.poll();
                if(toRight==1)
                    list.add(node.val);
                else
                    list.add(0,node.val);
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
            }

            toRight = 1-toRight;
            result.add(list);
        }
        return result;
    }
}


public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> sol = new ArrayList<>();
        travel(root, sol, 0);
        return sol;
    }

    private void travel(TreeNode curr, List<List<Integer>> sol, int level) {
        if(curr == null) return;

        if(sol.size() <= level) {
            List<Integer> newLevel = new LinkedList<>();
            sol.add(newLevel);
        }

        List<Integer> collection  = sol.get(level);
        if(level % 2 == 0) collection.add(curr.val);
        else collection.add(0, curr.val);

        travel(curr.left, sol, level + 1);
        travel(curr.right, sol, level + 1);
    }
}

************************************************************************************************************
*Problem 104 - Maximum Depth of Binary Tree
*
*Description:Given a binary tree, find its maximum depth.
*	     
*	     The maximum depth is the number of nodes along the longest path from the root node down to the 
*	     farthest leaf node.
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}

public class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0; 
        int count = 0; 
        Queue<TreeNode> q = new LinkedList<>(); 
        q.offer(root); 
        while(!q.isEmpty()){
            int levelNum = q.size(); 
            count++; 
            for(int i=0; i<levelNum; i++){
                TreeNode node = q.poll(); 
                if(node.left!=null) q.offer(node.left); 
                if(node.right!=null) q.offer(node.right); 
            }
        }
        return count; 
    }
}


************************************************************************************************************
*Problem 105 - Construct Binary Tree from Preorder and Inorder Traversal
*
*Description:Given preorder and inorder traversal of a tree, construct the binary tree.
*
*	     Note:
*		You may assume that duplicates do not exist in the tree.
*
*Parameter: (int[] preorder, int[] inorder)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(0, 0, inorder.length - 1, preorder, inorder);
    }

    public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {
        if (preStart > preorder.length - 1 || inStart > inEnd) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[preStart]);
        int inIndex = 0; // Index of current root in inorder
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == root.val) {
                inIndex = i;
            }
        }
        root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
        root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
        return root;
    }
}


************************************************************************************************************
*Problem 106 - Construct Binary Tree from Inorder and Postorder Traversal
*
*Description:Given inorder and postorder traversal of a tree, construct the binary tree.
*
*	     Note:
*		You may assume that duplicates do not exist in the tree.
*
*Parameter: (int[] inorder, int[] postorder)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTree(inorder, inorder.length-1, 0, postorder, postorder.length-1);
    }

    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart) {
        if (postStart < 0 || inStart < inEnd)
            return null;

        //The last element in postorder is the root.
        TreeNode root = new TreeNode(postorder[postStart]);

        //find the index of the root from inorder. Iterating from the end.
        int rIndex = inStart;
        for (int i = inStart; i >= inEnd; i--) {
            if (inorder[i] == postorder[postStart]) {
                rIndex = i;
                break;
            }
        }
        //build right and left subtrees. Again, scanning from the end to find the sections.
        root.right = buildTree(inorder, inStart, rIndex + 1, postorder, postStart-1);
        root.left = buildTree(inorder, rIndex - 1, inEnd, postorder, postStart - (inStart - rIndex) -1);
        return root;
    }
}


************************************************************************************************************
*Problem 107 - Binary Tree Level Order Traversal II 
*
*Description: (See website)
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
 
        if(root == null) return result;
 
        LinkedList<TreeNode> current = new LinkedList<TreeNode>();
        LinkedList<TreeNode> next = new LinkedList<TreeNode>();
        current.offer(root);
 
        List<Integer> numberList = new ArrayList<Integer>();
 
        // need to track when each level starts
        while(!current.isEmpty()){
            TreeNode head = current.poll();
 
            numberList.add(head.val);
 
            if(head.left != null){
                next.offer(head.left);
            }
            if(head.right!= null){
                next.offer(head.right);
            }
 
            if(current.isEmpty()){
                current = next;
                next = new LinkedList<TreeNode>();
                result.add(numberList);
                numberList = new ArrayList<Integer>();
            }
        }
 
        //return Collections.reverse(result);
        List<List<Integer>> reversedResult = new ArrayList<List<Integer>>();
        for(int i=result.size()-1; i>=0; i--){
            reversedResult.add(result.get(i));
        }
 
        return reversedResult;
    }
}


************************************************************************************************************
*Problem 108 - Convert Sorted Array to Binary Search Tree
*
*Description:Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
*
*Parameter: (int[] num)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedArrayToBST(int[] num) {
        return sortedArrayToBST(num, 0, num.length-1);
    }
    
    private TreeNode sortedArrayToBST(int[] arr, int start, int end) { 
	if (start > end) return null;
        int mid = (start + end) / 2;
        TreeNode node = new TreeNode(arr[mid]);
        node.left = sortedArrayToBST(arr, start, mid-1);
        node.right = sortedArrayToBST(arr, mid+1, end);
        return node;
    }
}


************************************************************************************************************
*Problem 109 - Convert Sorted List to Binary Search Tree
*
*Description:Given a singly linked list where elements are sorted in ascending order, convert it to a height 
*	     balanced BST.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private ListNode current;

    private int getListLength(ListNode head) {
        int size = 0;

        while (head != null) {
            size++;
            head = head.next;
        }

        return size;
    }

    public TreeNode sortedListToBST(ListNode head) {
        int size;

        current = head;
        size = getListLength(head);

        return sortedListToBSTHelper(size);
    }

    public TreeNode sortedListToBSTHelper(int size) {
        if (size <= 0) {
            return null;
        }

        TreeNode left = sortedListToBSTHelper(size / 2);
        TreeNode root = new TreeNode(current.val);
        current = current.next;
        TreeNode right = sortedListToBSTHelper(size - 1 - size / 2);

        root.left = left;
        root.right = right;

        return root;
    }
}


************************************************************************************************************
*Problem 110 - Balanced Binary Tree
*
*Description:Given a binary tree, determine if it is height-balanced.
*	     
*	     For this problem, a height-balanced binary tree is defined as a binary tree in which the depth 
*	     of the two subtrees of every node never differ by more than 1. 
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution1 {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }
    
    private int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}


public class Solution2 {
    public boolean isBalanced(TreeNode root) {
        return maxDepth(root) != -1;
    }
    
    private int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int L = maxDepth(root.left);
        if (L == -1) return -1;
        int R = maxDepth(root.right);
        if (R == -1) return -1;
        return (Math.abs(L - R) <= 1) ? (Math.max(L, R) + 1) : -1;
    }
}


************************************************************************************************************
*Problem 111 - Minimum Depth of Binary Tree
*
*Description:Given a binary tree, find its minimum depth.
*	     
*	     The minimum depth is the number of nodes along the shortest path from the root node down to the 
*	     nearest leaf node.
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null) return minDepth(root.right) + 1;
        if (root.right == null) return minDepth(root.left) + 1;
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    }
}


public class Solution {
    public int minDepth(TreeNode root) {
        if (root == null)
            return 0;
            
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int depth = 1;
        
        while(!queue.isEmpty()) {
            int size = queue.size(); // determine the loop size
            for(int i = 0; i< size; i++) {
                TreeNode node = queue.poll();
                if (node.left == null && node.right == null)
                    return depth;
                if (node.left!=null)
                    queue.add(node.left);
                if (node.right!=null)
                    queue.add(node.right);
            }
            depth ++;
        }
        return depth;
    }
}


************************************************************************************************************
*Problem 112 - Path Sum
*
*Description:Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up 
*	     all the values along the path equals the given sum. 
*
*Parameter: (TreeNode root, int sum)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null){
            return false;
        }
        
        if (root.left == null && root.right == null && sum == root.val){
            return true;
        }
        
        return (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val));
    }
}


************************************************************************************************************
*Problem 113 - Path Sum II (Factset)
*
*Description:Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the 
*	     given sum. 
*
*Parameter: (TreeNode root, int sum)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<Integer> currentList = new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        dfs (currentList, totalList, root, sum);
        return totalList;
    }
    
    private void dfs (List<Integer> currentList, List<List<Integer>> totalList, TreeNode root, int sum){
        if (root == null){
            return;
        }
        
        if (sum == root.val && root.left == null && root.right == null){
            currentList.add(root.val);
            totalList.add(new ArrayList<>(currentList));
            currentList.remove(currentList.size() - 1);
            return;
        }
        
        currentList.add(root.val);
        dfs (currentList, totalList, root.left, sum - root.val);
        dfs (currentList, totalList, root.right, sum - root.val);
        currentList.remove(currentList.size() - 1);
    }
}


************************************************************************************************************
*Problem 114 - Flatten Binary Tree to Linked List
*
*Description:Given a binary tree, flatten it to a linked list in-place.
*	     
*	     For example,
*	     Given
*
*	       1
*             / \
*            2   5
*           / \   \
*          3   4   6
*
*	     The flattened tree should look like:
*	       1
*	        \
*	         2
*	          \
*	           3
*	            \
*	             4
*	              \
*	               5
*	                \
*	                 6  
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private TreeNode lastNode = null;

    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }

        if (lastNode != null) {
            lastNode.left = null;
            lastNode.right = root;
        }

        lastNode = root;
        TreeNode right = root.right;
        flatten(root.left);
        flatten(right);
    }
}


************************************************************************************************************
*Problem 116 - Populating Next Right Pointers in Each Node (pre-order)
*
*Description:Populate each next pointer to point to its next right node. If there is no next right node, 
*	     the next pointer should be set to NULL.
*
*	     Initially, all next pointers are set to NULL.
*	     
*	       1
*             / \
*            2   3
*           / \ / \
*          4  5 6  7
*	       
*                1 -> NULL
*	       /  \
*	      2 -> 3 -> NULL
*	     / \  / \
*	    4->5->6->7 -> NULL*	     
*
*Parameter: (int numRows)
************************************************************************************************************
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if (root == null || root.left == null || root.right == null) return;

        root.left.next = root.right;
        root.right.next = root.next == null ? null : root.next.left; ／／ CONNECTING THE GAP
        connect(root.left);
        connect(root.right);
    }
}


************************************************************************************************************
*Problem 117 - Populating Next Right Pointers in Each Node II
*
*Description:  
*
*Parameter: (int numRows)
************************************************************************************************************
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        TreeLinkNode queue = root;
        while (queue != null) {
            TreeLinkNode level = new TreeLinkNode(0);
            TreeLinkNode current = level;
            while (queue != null) {
                if (queue.left != null) {
                    current.next = queue.left;
                    current = current.next;
                }
                if (queue.right != null) {
                    current.next = queue.right;
                    current = current.next;
                }
                queue = queue.next;
            }
            queue = level.next;
        }
    }
}


public class Solution {
    public static void connect(TreeLinkNode root) {
        if (root == null) return;

        TreeLinkNode t = root.next;
        while (t != null) {
            if (t.left != null) {
                t = t.left;
                break;
            } else if (t.right != null) {
                t = t.right;
                break;
            } else {
                t = t.next;
            }
        }
        if (root.right != null) {
            root.right.next = t;
        }
        if (root.left != null) {
            if (root.right != null) {
                root.left.next = root.right;
            } else {
                root.left.next = t;
            }
        }
        connect(root.right);
        connect(root.left);
    }
}


************************************************************************************************************
*Problem 118 - Pascal's Triangle 
*
*Description:Given numRows, generate the first numRows of Pascal's triangle.
*	     
*	     For example, given numRows = 5,
*
*	     Return
*	       
*              [
*  		     [1],
*  		    [1,1],
*  		   [1,2,1],
*  		  [1,3,3,1],
*  		 [1,4,6,4,1]
*	       ]
*	     
*
*Parameter: (int numRows)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> generate(int numRows) {
        if (numRows < 1) return new ArrayList<List<Integer>>();
        
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        List<Integer> initList = new ArrayList<Integer>();
        initList.add(1);
        totalList.add(new ArrayList<>(initList));
        
        for (int i = 2; i <= numRows; i++){ // STARTING FROM ROW 2
            List<Integer> currentList = new ArrayList<Integer>();
            currentList.add(1);
            for(int j = 1; j < i - 1; j++){ // IN EACH ROW, STARTING FROM INDEX = 1, ENDING INDEX = LENGTH - 2
                currentList.add(totalList.get(i-2).get(j-1) + totalList.get(i-2).get(j));
            }
            currentList.add(1);
            totalList.add(new ArrayList<>(currentList));
        }
        return totalList;
    }
}


************************************************************************************************************
*Problem 119 - Pascal's Triangle II 
*
*Description:Given an index k, return the kth row of the Pascal's triangle.
*	     
*	     For example, given k = 3,
*
*	     Return [1,3,3,1].
*
*Parameter: (int numRows)
************************************************************************************************************
public class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<Integer>();
        if(rowIndex<0) return res;
    
        res.add(1);
        
        for(int i=1;i<=rowIndex;i++){
            for(int j=res.size()-2;j>=0;j--){
                res.set(j+1,res.get(j)+res.get(j+1));
            }
            res.add(1);
        }
        return res;
    }
}


************************************************************************************************************
*Problem 120 - Triangle 
*
*Description:Given a triangle, find the minimum path sum from top to bottom. Each step you may move to 
*	     adjacent numbers on the row below.
*	     
*	     For example, given the following triangle
*
*	     Return
*	       
*              [
*  		     [2],
*  		    [3,4],
*  		   [6,5,7],
*  		  [4,1,8,3]
*	       ]
*	     
*	     The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
*
*	     Note:
*	     Bonus point if you are able to do this using only O(n) extra space, where n is the total number 
*	     of rows in the triangle.
*
*Parameter: (List<List<Integer>> triangle)
************************************************************************************************************
public class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle == null || triangle.size() == 0) {
            return 0;
        }

        int n = triangle.size();
        int[][] sum = new int[n][n];

        for (int i = 0; i < n; i++) {
            sum[n - 1][i] = triangle.get(n - 1).get(i);
        }

        for (int i = n - 2; i >= 0; i--) { 
            for (int j = 0; j <= i; j++) {
                sum[i][j] = Math.min(sum[i + 1][j], sum[i + 1][j + 1]) + triangle.get(i).get(j);
            }
        }

        return sum[0][0];
    }
}


************************************************************************************************************
*Problem 121 - Best Time to Buy and Sell Stock 
*
*Description:Say you have an array for which the ith element is the price of a given stock on day i.
*	     
*	     If you were only permitted to complete at most one transaction (ie, buy one and sell one share 
*	     of the stock), design an algorithm to find the maximum profit.
*
*Parameter: (int[] prices)
************************************************************************************************************
public class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE, profit = 0;
        for (int i : prices) {
            min = Math.min(i, min);
            profit = Math.max(i - min, profit);
        }
        return profit;
    }
}

public class Solution2 {
    public int maxProfit(int[] prices) {

        int min = Integer.MAX_VALUE;  //just remember the smallest price
        int profit = 0;
        for (int i : prices) {
            min = i < min ? i : min;
            profit = (i - min) > profit ? i - min : profit;
        }

        return profit;
    }
}


************************************************************************************************************
*Problem 122 - Best Time to Buy and Sell Stock II 
*
*Description:Say you have an array for which the ith element is the price of a given stock on day i.
*	     
*	     Design an algorithm to find the maximum profit. You may complete as many transactions as you 
*	     like (ie, buy one and sell one share of the stock multiple times). However, you may not engage 
*	     in multiple transactions at the same time (ie, you must sell the stock before you buy again).
*
*Parameter: (int[] prices)
************************************************************************************************************
public class Solution {
    public int maxProfit(int[] prices) {
        int total = 0;
        for (int i=0; i< prices.length-1; i++)
            if (prices[i+1]>prices[i]) 
                total += prices[i+1]-prices[i];
    
        return total;
    }
}


************************************************************************************************************
*Problem 123 - Best Time to Buy and Sell Stock III
*
*Description:Say you have an array for which the ith element is the price of a given stock on day i.
*	     
*	     Design an algorithm to find the maximum profit. You may complete at most two transactions. 
*
*	     Note:
*
*	     You may not engage in multiple transactions at the same time (ie, you must sell the stock 
*	     before you buy again).
*
*Parameter: (int[] prices)
************************************************************************************************************
public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }

        int[] left = new int[prices.length];
        int[] right = new int[prices.length];

        // DP from left to right;
        left[0] = 0;
        int min = prices[0];
        for (int i = 1; i < prices.length; i++) {
            min = Math.min(prices[i], min);
            left[i] = Math.max(left[i - 1], prices[i] - min);
        }

        //DP from right to left;
        right[prices.length - 1] = 0;
        int max = prices[prices.length - 1];
        for (int i = prices.length - 2; i >= 0; i--) {
            max = Math.max(prices[i], max);
            right[i] = Math.max(right[i + 1], max - prices[i]);
        }

        int profit = 0;
        for (int i = 0; i < prices.length; i++){
            profit = Math.max(left[i] + right[i], profit);  
        }

        return profit;
    }
}


************************************************************************************************************
*Problem 125 - Valid Palindrome
*
*Description:Given a string, determine if it is a palindrome, considering only alphanumeric characters and 
*	     ignoring cases.
*	     
*	     For example,
*	     "A man, a plan, a canal: Panama" is a palindrome.
*	     "race a car" is not a palindrome.
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;
        while (i < j) {
            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;
            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;
            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {
                return false;
            }
            i++; j--;
        }
        return true;
    }
}


************************************************************************************************************
*Problem 127 - Word Ladder
*
*Description:Given two words (beginWord and endWord), and a dictionary, find the length of shortest 
*	     transformation sequence from beginWord to endWord, such that:
*	     
*	     1. Only one letter can be changed at a time
*	     2. Each intermediate word must exist in the dictionary
*
*	     For example,
*	     Given:  
*              start = "hit"
*  	       end = "cog"
*  	       dict = ["hot","dot","dog","lot","log"]
*  		   
*  	       As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
*  	       return its length 5.
*	       
*	     Note:
*	       Return 0 if there is no such transformation sequence.
*	       All words have the same length.
*	       All words contain only lowercase alphabetic characters.
*
*Parameter: (String start, String end, Set<String> dict)
************************************************************************************************************
public class Solution {
    public int ladderLength(String start, String end, Set<String> dict) {
        if (dict == null || dict.size() == 0) {
            return 0;
        }

        Queue<String> queue = new LinkedList<String>();
        queue.offer(start);
        dict.remove(start);
        int length = 1;

        while(!queue.isEmpty()) {
            int count = queue.size();
            for (int i = 0; i<count; i++){
                String current = queue.poll();
                for (char c = 'a'; c <= 'z'; c++) {
                    for (int j=0; j < current.length(); j++) {
                        if (c == current.charAt(j)) {
                            continue;
                        }
                        String tmp = replace(current, j, c);
                        if (tmp.equals(end)) {
                            return length + 1;
                        }
                        if (dict.contains(tmp)){
                            queue.offer(tmp);
                            dict.remove(tmp);
                        }
                    }
                }
            }
            length++;
        }
        return 0;
    }

    private String replace(String s, int index, char c) {
        char[] chars = s.toCharArray();
        chars[index] = c;
        return new String(chars);
    }
}


************************************************************************************************************
*Problem 129 - Sum Root to Leaf Numbers
*
*Description:Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a 
*	     number.
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumNumbers(TreeNode root) {
        int currentVal = 0;
        int totalVal = 0;
        return dfs(currentVal, totalVal, root);

    }
    
    private int dfs(int currentVal, int totalVal, TreeNode root){
        if(root == null){
            return totalVal;
        }
        
        currentVal = currentVal*10 + root.val;
        
        if(root.left == null && root.right == null){
            totalVal += currentVal;
            return totalVal;
        }
        
        totalVal = dfs(currentVal, totalVal, root.left) + dfs(currentVal, totalVal, root.right);
        
        return totalVal;
    }
}


************************************************************************************************************
*Problem 130 - Surrounded Regions
*
*Description:Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'.
*
*		A region is captured by flipping all 'O's into 'X's in that surrounded region.
*
*		For example,
*		X X X X
*		X O O X
*		X X O X
*		X O X X
*		After running your function, the board should be:
*
*		X X X X
*		X X X X
*		X X X X
*		X O X X
*
*Parameter: (char[][] board)
************************************************************************************************************

************************************************************************************************************
*Problem 131 - Palindrome Partitioning 
*
*Description:Given a string s, partition s such that every substring of the partition is a palindrome.
*	     
*	     Return all possible palindrome partitioning of s.
*
*	     For example, given s = "aab",
*
*	     Return
*	     [
*	       ["aa","b"],
*	       ["a","a","b"]
*	     ]
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<List<String>>();
        if (s == null) {
            return result;
        }

        List<String> path = new ArrayList<String>();
        helper(s, path, 0, result);

        return result;
    }

    private boolean isPalindrome(String s) {
        int beg = 0;
        int end = s.length() - 1;
        while (beg < end) {
            if (s.charAt(beg) != s.charAt(end)) {
                return false;
            }

            beg++;
            end--;
        }

        return true;
    }

    private void helper(String s, List<String> path, int pos, List<List<String>> result) {
        if (pos == s.length()) {
            result.add(new ArrayList<String>(path));
            return;
        }

        for (int i = pos + 1; i <= s.length(); i++) {
            String prefix = s.substring(pos, i);
            if (!isPalindrome(prefix)) {
                continue;
            }

            path.add(prefix);
            helper(s, path, i, result);
            path.remove(path.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 136 - Single Number
*
*Description:Given an array of integers, every element appears twice except for one. Find that single one.
*	     
*	     Note:
*
*	     Your algorithm should have a linear runtime complexity. Could you implement it without using 
*	     extra memory?
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int singleNumber(int[] A) {
	    HashSet<Integer> set = new HashSet<Integer>();
	    for (int n : A) {
		    if (!set.add(n))
			    set.remove(n);
	    }
	    Iterator<Integer> it = set.iterator();
	    return it.next();
    }
}


************************************************************************************************************
*Problem 137 - Single Number II 
*
*Description:Given an array of integers, every element appears three times except for one. Find that single 
*	     one.
*	     
*	     Note:
*
*	     Your algorithm should have a linear runtime complexity. Could you implement it without using 
*	     extra memory?
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int singleNumber(int[] A) {
        int ones = 0, twos = 0, threes = 0;
        for (int i = 0; i < A.length; i++) {
            twos |= ones & A[i];
            ones ^= A[i];
            threes = ones & twos;
            ones &= ~threes;
            twos &= ~threes;
        }
        return ones;
    }
}


************************************************************************************************************
*Problem 138 - Copy List with Random Pointer 
*
*Description:A linked list is given such that each node contains an additional random pointer which could 
*	     point to any node in the list or null.
*
*	     Return a deep copy of the list.
*
*Parameter: (RandomListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {
        Map<RandomListNode, RandomListNode> map = new HashMap<>();
        RandomListNode p = head;
        RandomListNode dummy = new RandomListNode(0);
        RandomListNode q = dummy;
        while (p != null) {
            q.next = new RandomListNode(p.label);
            map.put(p, q.next);
            p = p.next;
            q = q.next;
        }
        p = head;
        q = dummy;
        while (p != null) {
            q.next.random = map.get(p.random);
            p = p.next;
            q = q.next;
        }
    return dummy.next;
    }
}


************************************************************************************************************
*Problem 139 - Word Break 
*
*Description:Given a string s and a dictionary of words dict, determine if s can be segmented into a 
*	     space-separated sequence of one or more dictionary words.
*	     
*	     For example, given
*
*	     s = "leetcode",
*	     dict = ["leet", "code"].
*
*	     Return true because "leetcode" can be segmented as "leet code".
*
*Parameter: (String s, Set<String> dict)
************************************************************************************************************
public class Solution {
    public boolean wordBreak(String s, Set<String> dict) {
        boolean[] t = new boolean[s.length()+1];
        t[0] = true; //set first to be true, why?
        //Because we need initial state
 
        for(int i=0; i<s.length(); i++){
            //should continue from match position
            if(!t[i]) 
                continue;
 
            for(String a: dict){
                int len = a.length();
                int end = i + len;
                if(end > s.length())
                    continue;
 
                if(t[end]) continue;
 
                if(s.substring(i, end).equals(a)){
                    t[end] = true;
                }
            }
        }
 
        return t[s.length()];
    }
}


************************************************************************************************************
*Problem 141 - Linked List Cycle
*
*Description:Given a linked list, determine if it has a cycle in it. 
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head, slow = head;
 
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
 
            if(slow == fast)
                return true;
        }
 
        return false;
    }
}


************************************************************************************************************
*Problem 143 - Reorder List
*
*Description:Given a singly linked list L: L0→L1→…→Ln-1→Ln,
*	     reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…
*	     You must do this in-place without altering the nodes' values.
*	     For example,
*	     Given {1,2,3,4}, reorder it to {1,4,2,3}.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void reorderList(ListNode head) {
        if(head == null || head.next == null || head.next.next == null){
            return;
        }
        
        ListNode cur = head;
        ListNode slow = head, fast = head; // NO DUMMY, DEPARTURE FROM HEAD
        
        while(fast.next != null && fast.next.next != null){ // REACH MIDDLE POINT
            fast = fast.next.next;
            slow = slow.next;
        }
        
        ListNode newHead = reverseList(slow); // THINK: REVERSED HALF CHAIN ON TOP OF ORIGINAL HALF
        
        while(newHead.next != null || cur.next != null){
            ListNode curNext = cur.next;
            ListNode newHeadNext = newHead.next;
            
            cur.next = newHead;
            
            if(newHead != curNext){
                newHead.next = curNext; // THIS IS A ZIZAG LIKE LINKING
            } 
    
            cur = curNext;
            newHead = newHeadNext;
            
            if(cur == null) return; // SPECIAL PRE TERMINATE: EVEN LIST
        }
        return; // NORMAL TERMINATE: ODD LIST
    }
    
    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;
        
        while(cur != null){
            ListNode originalNext = cur.next;
            cur.next = prev;
            prev = cur;
            cur = originalNext;
        }
        return prev;
    }
}


************************************************************************************************************
*Problem 144 - Binary Tree Preorder Traversal
*
*Description:Given a binary tree, return the preorder traversal of its nodes' values.
*	     
*	     For example,
*	     Given binary tree {1,#,2,3},
*		 1
*	          \
*	           2
*	          /
*	         3
*
*	     return [1,2,3].
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();

        if (root == null) return list;

        stack.push(root);

        while (!stack.isEmpty()) { // IS EMPTY?
            TreeNode temp = stack.pop(); // KEEP POPPING OUT
            if (temp != null) {
                list.add(temp.val);
                stack.push(temp.right); // PUSH NULL EVENTUALLY
                stack.push(temp.left); 
            }
        }
        return list;
    }
}


public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer>();
        preOederDFS(list, root);
        return list;
    }
    
    public void preOederDFS(List<Integer> list, TreeNode node){
        if(node == null) return;
        list.add(node.val);
        preOederDFS(list, node.left);
        preOederDFS(list, node.right);
    }
}


************************************************************************************************************
*Problem 145 - Binary Tree Postorder Traversal
*
*Description:Given a binary tree, return the preorder traversal of its nodes' values.
*	     
*	     For example,
*	     Given binary tree {1,#,2,3},
*		 1
*	          \
*	           2
*	          /
*	         3
*
*	     return [3,2,1].
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();

        if (root == null) return list;

        stack.push(root);

        while (!stack.isEmpty()) {
            TreeNode temp = stack.pop();
            if (temp != null) {
                list.add(0, temp.val);
                stack.push(temp.left);
                stack.push(temp.right); 
            }
        }
        return list;
    }
}


public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer>();
        postorderDFS(list, root);
        return list;
    }
    
    public void postorderDFS(List<Integer> list, TreeNode node){
        if(node == null) return;
        postorderDFS(list, node.left);
        postorderDFS(list, node.right);
        list.add(node.val);
    }
}


************************************************************************************************************
*Problem 146 - LRU Cache
*
*Description:Design and implement a data structure for Least Recently Used (LRU) cache. It should support 
*	     the following operations: get and set.
*
*	get(key) - Get the value (will always be positive) of the key if the key exists in the cache, 
*	otherwise return -1.
*	
*	set(key, value) - Set or insert the value if the key is not already present. When the cache reached 
*	its capacity, it should invalidate the least recently used item before inserting a new item.
*
*Parameter:
************************************************************************************************************
public class LRUCache {
    
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode pre;
        DLinkedNode post;
    }

    /**
    * Always add the new node right after head;
    */
    private void addNode(DLinkedNode node){
        node.pre = head;
        node.post = head.post;

        head.post.pre = node;
        head.post = node;
    }

    /**
    * Remove an existing node from the linked list.
    */
    private void removeNode(DLinkedNode node){
        DLinkedNode pre = node.pre;
        DLinkedNode post = node.post;

        pre.post = post;
        post.pre = pre;
    }

    /**
    * Move certain node in between to the head.
    */
    private void moveToHead(DLinkedNode node){
        this.removeNode(node);
        this.addNode(node);
    }

    // pop the current tail. 
    private DLinkedNode popTail(){
        DLinkedNode res = tail.pre;
        this.removeNode(res);
        return res;
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int count;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.count = 0;
        this.capacity = capacity;

        head = new DLinkedNode();
        head.pre = null;

        tail = new DLinkedNode();
        tail.post = null;

        head.post = tail;
        tail.pre = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if(node == null)
            return -1; // should raise exception here.

        // move the accessed node to the head;
        this.moveToHead(node);

        return node.value;
    }


    public void set(int key, int value) {
        DLinkedNode node = cache.get(key);

        if(node == null){
            DLinkedNode newNode = new DLinkedNode();
            newNode.key = key;
            newNode.value = value;

            this.cache.put(key, newNode);
            this.addNode(newNode);

            ++count;

            if(count > capacity){
                // pop the tail
                DLinkedNode tail = this.popTail();
                this.cache.remove(tail.key);
                --count;
            }
        }else{
            // update the value.
            node.value = value;
            this.moveToHead(node);
        }

    }
}


************************************************************************************************************
*Problem 147 - Insertion Sort List
*
*Description:Sort a linked list using insertion sort.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(0);
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur!=null){
            ListNode next = cur.next;
            pre = dummy;
            while(pre.next!=null && pre.next.val<=cur.val){
                pre = pre.next;
            }
            cur.next = pre.next;
            pre.next = cur;
            cur = next;
        }
        return dummy.next;
    }
}


************************************************************************************************************
*Problem 148 - Sort List (I use merge sort here)
*
*Description:Sort a linked list in O(n log n) time using constant space complexity.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode sortList(ListNode head) {
        return mergeSort(head);
    }
    
    private ListNode mergeSort(ListNode head){
        if(head == null || head.next == null)
            return head;
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next!=null && fast.next.next!=null){ // CONVENTION TO REACH MIDDLE POINT
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode head2 = slow.next; // CUT THE LINK FROM MIDDLE
        slow.next = null;
        ListNode head1 = head;
        head1 = mergeSort(head1);
        head2 = mergeSort(head2);
        return merge(head1, head2);
    }
    
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead; // DEPARTURE FROM DUMMY
        
        while(l1 != null && l2 != null){
            if(l1.val < l2.val){
                cur.next = l1;
                l1 = l1.next;
            } else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next; // UPDATING cur
        }
        
        if(l1 != null) cur.next = l1;
        if(l2 != null) cur.next = l2;
        
        return dummyHead.next;
    }
}


************************************************************************************************************
*Problem 151 - Reverse Words in a String
*
*Description:Given an input string, reverse the string word by word..
*	     For example,
*	     Given s = "the sky is blue",
*	     return "blue is sky the".
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public String reverseWords(String s) {
        StringBuilder reversed = new StringBuilder();
        int j = s.length();
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == ' ') {
                j = i;
            } else if (i == 0 || s.charAt(i - 1) == ' ') {
                if (reversed.length() != 0) {
                    reversed.append(' ');
                }
                reversed.append(s.substring(i, j)); // i INCLUSIVE, j EXCLUSIVE
            }
        }
        return reversed.toString();
    }
}


************************************************************************************************************
*Problem 152 - Maximum Product Subarray
*
*Description:Find the contiguous subarray within an array (containing at least one number) which has the 
*	     largest product.
*
*	     For example, given the array [2,3,-2,4],
*	     
*	     the contiguous subarray [2,3] has the largest product = 6.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int maxProduct(int[] nums) {
        assert nums.length > 0;
        int max = nums[0], min = nums[0], maxAns = nums[0];
        for (int i = 1; i < nums.length; i++) {
            int mx = max, mn = min;
            max = Math.max(Math.max(nums[i], mx * nums[i]), mn * nums[i]);
            min = Math.min(Math.min(nums[i], mx * nums[i]), mn * nums[i]);
            maxAns = Math.max(max, maxAns);
        }
        return maxAns;
    }
}


************************************************************************************************************
*Problem 153 - Find Minimum in Rotated Sorted Array 
*
*Description:Suppose a sorted array is rotated at some pivot unknown to you beforehand.
*	     (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
*	     Find the minimum element.
*	     You may assume no duplicate exists in the array.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while(left < right){
            if(right - left == 1) break;
            
            int mid = (left + right)/2;
            
            if(nums[left] > nums[right]) { // COMPARE LEFT AND RIGHT
                if(nums[left] < nums[mid]){ // COMPARE LEFT AND MID
                    left = mid + 1;
                } else {
                    right = mid;
                }
            } else {
                right = mid;
            }
        }
        return (nums[left] < nums[right]) ? nums[left] : nums[right]; // ONLY 2 ELEMENTS LEFT
    }
}


************************************************************************************************************
*Problem 154 - Find Minimum in Rotated Sorted Array II 
*
*Description:Suppose a sorted array is rotated at some pivot unknown to you beforehand.
*	     (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
*	     Find the minimum element.
*	     The array may contain duplicates.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while(left < right){
            if(right - left == 1) break;
            
            int mid = (left + right)/2;
            
            if(nums[left] >= nums[right]) { // COMPARE LEFT AND RIGHT
                if(nums[left] < nums[mid]){ // COMPARE LEFT AND MID
                    left = mid + 1;
                } else if (nums[left] == nums[mid]){ // SPECIAL CASE
                    left++; // ONLY ADVANCE LEFT
                } else {
                    right = mid;
                }
            } else {
                right = mid;
            }
        }
        return (nums[left] < nums[right]) ? nums[left] : nums[right]; // ONLY 2 ELEMENTS LEFT
    }
}


************************************************************************************************************
*Problem 155 - Min Stack
*
*Description:Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
*	     
*	     push(x) -- Push element x onto stack.
*	     pop() -- Removes the element on top of the stack.
*	     top() -- Get the top element.
*	     getMin() -- Retrieve the minimum element in the stack.
*
*Parameter: 
************************************************************************************************************
class MinStack {
    private Stack<Integer> stack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();
    
    public void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) {
            minStack.push(x);
        }
    }

    public void pop() {
        if (stack.pop().equals(minStack.peek())) minStack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}


************************************************************************************************************
*Problem 157 - Read N Characters Given Read4
*
*Description:
*	The API: int read4(char *buf) reads 4 characters at a time from a file.
*
*	The return value is the actual number of characters read. For example, it returns 3 if there is only 
*	3 characters left in the file.
*
*	By using the read4 API, implement the function int read(char *buf, int n) that reads n characters 
*	from the file.
*
*	Note:
*	The read function will only be called once for each test case.
*
*Parameter: (char[] buf, int n)
************************************************************************************************************
/* The read4 API is defined in the parent class Reader4.
      int read4(char[] buf); */

public class Solution extends Reader4 {
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    public int read(char[] buf, int n) {
        char[] buffer = new char[4];
        int readBytes = 0;
        boolean eof = false;
        while (!eof && readBytes < n) {
            int sz = read4(buffer);
            if (sz < 4) eof = true;
            int bytes = Math.min(n - readBytes, sz); 
            System.arraycopy(buffer /*src*/, 0 /*srcPos*/, buf /*dest*/, readBytes /*destPos*/, bytes /*length*/);
            readBytes += bytes;
        }
        return readBytes;
   }
}


************************************************************************************************************
*Problem 158 - Read N Characters Given Read4 II - Call multiple times
*
*Description:
*
*	The API: int read4(char *buf) reads 4 characters at a time from a file.
*
*	The return value is the actual number of characters read. For example, it returns 3 if there is only 
*	3 characters left in the file.
*
*	By using the read4 API, implement the function int read(char *buf, int n) that reads n characters 
*	from the file.
*
*	Note:
*	The read function may be called multiple times.
*
*Parameter: (char[] buf, int n)
************************************************************************************************************
/* The read4 API is defined in the parent class Reader4.
      int read4(char[] buf); */

public class Solution extends Reader4 {
    private char[] buffer = new char[4]; 
    int offset = 0, bufsize = 0;
    
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    public int read(char[] buf, int n) { 
        int readBytes = 0;
        boolean eof = false;
        while(!eof && readBytes < n) {
            if(bufsize == 0) {
                bufsize = read4(buffer); 
                eof = bufsize < 4;
            }
            int bytes = Math.min(n - readBytes, bufsize); 
            System.arraycopy(buffer /*src*/, offset /*srcPos*/, buf /*dest*/, readBytes /*destPos*/, bytes /*length*/);
            offset = (offset + bytes) % 4;
            bufsize -= bytes;
            readBytes += bytes;
        }
        return readBytes; 
    }
}


************************************************************************************************************
*Problem 160 - Intersection of Two Linked Lists 
*
*Description:Write a program to find the node at which the intersection of two singly linked lists begins. 
*
*Parameter: (ListNode headA, ListNode headB)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
          if (headA == null || headB == null) {
              return null;
          }
          
          int lenA = getLen(headA);
          int lenB = getLen(headB);
          
          if (lenA > lenB) {
             while (lenA > lenB) {
                 headA = headA.next;
                 lenA--;
             }
         } else {
             while (lenA < lenB) {
                 headB = headB.next;
                 lenB--;
             }
         }
         
         while (headA != null) {
             if (headA == headB) {
                 return headA;
             }
             headA = headA.next;
             headB = headB.next;
         }
         
         return null;
     }
     
     public int getLen(ListNode node) {
         int len = 0;
         while (node != null) {
             len++;
             node = node.next;
         }
         return len;
     }
 }


************************************************************************************************************
*Problem 162 - Find Peak Element 
*
*Description:A peak element is an element that is greater than its neighbors.
*	     For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the 
*	     index number 2.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution1 {
    public int findPeakElement(int[] nums) {
        for (int i = 1; i < nums.length; i++){
            if(nums[i]<nums[i-1]){
                return i-1;
            }
        }
        return nums.length-1;
    }
}

public class Solution2 {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length-1;
        
        while(left < right){
            if(left == right){
                break;
            }
            
            int mid = (left + right)/2;
            
            if(nums[mid] < nums[mid+1]){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}


************************************************************************************************************
*Problem 163 - Missing Ranges 
*
*Description:Given a sorted integer array where the range of elements are [lower, upper] inclusive, return 
*	     its missing ranges.
*
*	     For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, 
*	     return ["2", "4->49", "51->74", "76->99"].
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public List<String> findMissingRanges(int[] vals, int start, int end) {
        List<String> ranges = new ArrayList<>();
        int prev = start - 1;
        for (int i = 0; i <= vals.length; i++) {
            int curr = (i == vals.length) ? end + 1 : vals[i];
            if (curr - prev >= 2) {
                ranges.add(getRange(prev + 1, curr - 1));
            }
            prev = curr; 
        }
        return ranges;
    }

    private String getRange(int from, int to) {
        return (from == to) ? String.valueOf(from) : from + "->" + to;
    }
}


************************************************************************************************************
*Problem 164 - One Edit Distance 
*
*Description:Given two strings S and T, determine if they are both one edit distance apart.
*
*Parameter: (String s, String t)
************************************************************************************************************
public class Solution {
    public boolean isOneEditDistance(String s, String t) {
        for (int i = 0; i < Math.min(s.length(), t.length()); i++) {
            if (s.charAt(i) != t.charAt(i)) {
		return s.substring(i+(s.length()>=t.length()?1:0)).equals(t.substring(i+(s.length()<=t.length()?1:0)));
            }
        }
        return Math.abs(s.length() - t.length()) == 1;
    }
}


************************************************************************************************************
*Problem 167 - Two Sum II - Input array is sorted
*
*Description:Given an array of integers that is already sorted in ascending order, find two numbers such 
*	that they add up to a specific target number.
*
*	The function twoSum should return indices of the two numbers such that they add up to the target, 
*	where index1 must be less than index2. Please note that your returned answers (both index1 and index2) 
*	are not zero-based.
*
*	You may assume that each input would have exactly one solution.
*
*	Input: numbers={2, 7, 11, 15}, target=9
*	Output: index1=1, index2=2
*
*Parameter: (int[] numbers, int target)
************************************************************************************************************
public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        // Assume input is already sorted.
        for (int i = 0; i < numbers.length; i++) {
        int j = bsearch(numbers, target - numbers[i],  i + 1);
        if (j != -1) {
            return new int[] { i + 1, j + 1 }; }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
    
    private int bsearch(int[] A, int key, int start) {
        int L = start, R = A.length - 1;
        while (L < R) {
            int M = (L + R) / 2;
            if (A[M] < key) {
            L = M + 1;
        } else {
            R = M; }
        }
        return (L == R && A[L] == key) ? L : -1;
    }
}


public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        // Assume input is already sorted.
        int i = 0, j = numbers.length - 1;
        while (i < j) {
            int sum = numbers[i] + numbers[j];
            if (sum < target) {
                i++;
            } else if (sum > target) {
                j--; 
            } else {
                return new int[] { i + 1, j + 1 }; 
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}


************************************************************************************************************
*Problem 168 - Excel Sheet Column Title 
*
*Description:Given a positive integer, return its corresponding column title as appear in an Excel sheet.
*	     
*	     For example,
*
*	     1 -> A
*	     2 -> B  
*            3 -> C
*  	     ...
*  	     26 -> Z
*  	     27 -> AA
*  	     28 -> AB 
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public String convertToTitle(int n) {
        String res = "";
        while(n != 0) {
            res = (char)((n - 1) % 26 + 'A') + res;
            n = (n - 1) / 26;
        }
        return res;
    }
}


************************************************************************************************************
*Problem 169 - Majority Element 
*
*Description:Given an array of size n, find the majority element. The majority element is the element that 
*	     appears more than ⌊ n/2 ⌋ times. 
*	     You may assume that the array is non-empty and the majority element always exist in the array.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}


************************************************************************************************************
*Problem 171 - Excel Sheet Column Number 
*
*Description:Related to question Excel Sheet Column Title
*
*	     Given a column title as appear in an Excel sheet, return its corresponding column number.
*	     
*	     For example,
*
*	     A -> 1
*	     B -> 2
*	     C -> 3
*	     ...
*	     Z -> 26
*	     AA -> 27
*	     AB -> 28
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public int titleToNumber(String s) {
        int num = 0;
        for (int i=0; i<s.length(); ++i)
            num = num * 26 + s.charAt(i) - 'A' + 1;
            
        return num;
    }
}


************************************************************************************************************
*Problem 172 - Factorial Trailing Zeroes (de Polignac's formula)
*
*Description:Given an integer n, return the number of trailing zeroes in n!.
*
*	     Note: Your solution should be in logarithmic time complexity.
*	     
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public int trailingZeroes(int n) {
        if ( n<0 ) return -1;
        int count = 0;
        for (long i=5; n/i>=1; i*=5) {
            count += n / i;
        }        
        return count;
    }
}


************************************************************************************************************
*Problem 173 - Binary Search Tree Iterator
*
*Description:Implement an iterator over a binary search tree (BST). Your iterator will be initialized with 
*	     the root node of a BST.
*
*	     Calling next() will return the next smallest number in the BST.
*
*	     Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the 
*	     height of the tree.
*	     
*Parameter: 
************************************************************************************************************
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class BSTIterator {
	Stack<TreeNode> stack;
 
	public BSTIterator(TreeNode root) {
		stack = new Stack<TreeNode>();
		while (root != null) {
			stack.push(root);
			root = root.left;
		}
	}
 
	public boolean hasNext() {
		return !stack.isEmpty();
	}
 
	public int next() {
		TreeNode node = stack.pop();
		int result = node.val;
		if (node.right != null) {
			node = node.right;
			while (node != null) {
				stack.push(node);
				node = node.left;
			}
		}
		return result;
	}
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */


************************************************************************************************************
*Problem 175 - Combine Two Tables
*
*Description:
*
Table: Person

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.
Table: Address

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.

Write a SQL query for a report that provides the following information for each person in the Person table, 
regardless if there is an address for each of those people:

FirstName, LastName, City, State
*	     
*Parameter: 
************************************************************************************************************
SELECT p.FirstName, p.LastName, a.City, a.State
FROM Person p
LEFT JOIN Address a
ON p.PersonId = a.PersonId


************************************************************************************************************
*Problem 176 - Second Highest Salary
*
*Description:
*
Write a SQL query to get the second highest salary from the Employee table.

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
For example, given the above Employee table, the second highest salary is 200. If there is no second highest salary, then the query should return null.
*	     
*Parameter: 
************************************************************************************************************
# Write your MySQL query statement below
SELECT max(Salary) 
FROM Employee 
WHERE Salary < (SELECT max(Salary) FROM Employee)


************************************************************************************************************
*Problem 181 - Employees Earning More Than Their Managers
*
*Description:
*
The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.

+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.

+----------+
| Employee |
+----------+
| Joe      |
+----------+
*	     
*Parameter: 
************************************************************************************************************
select E1.Name 
from Employee as E1, Employee as E2 
where E1.ManagerId = E2.Id and E1.Salary > E2.Salary


select a.Name
from Employee a 
inner join Employee b 
on a.ManagerId=b.Id
where a.Salary>b.Salary


************************************************************************************************************
*Problem 182 - Duplicate Emails
*
*Description:
*
Write a SQL query to find all duplicate emails in a table named Person.

+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
For example, your query should return the following for the above table:

+---------+
| Email   |
+---------+
| a@b.com |
+---------+
Note: All emails are in lowercase.
*	     
*Parameter: 
************************************************************************************************************
Select Email
From Person
GROUP BY Email
Having count(Email)>1


************************************************************************************************************
*Problem 186 - Reverse Words in a String II
*
*Description:“The input string does not contain leading or trailing spaces and the words are always separated 
*	     by a single space.”
*	     Could you do it in-place without allocating extra space?
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public void reverseWords(char[] s) {
        reverse(s, 0, s.length-1);
        int i = 0;
        for (int j = 0; j <= s.length; j++) {
            if (j == s.length || s[j] == ' ') {
                reverse(s, i, j-1);
                i = j + 1;
            }
        }
    }
    
    private void reverse(char[] s, int begin, int end) {
        while(begin < end) {
            char tem = s[begin];
            s[begin] = s[end];
            s[end] = tem;
            begin++;
            end--;
        }
    }
}   


************************************************************************************************************
*Problem 189 - Rotate Array
*
*Description:Rotate an array of n elements to the right by k steps. 
*	     For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].
*
*Parameter: (int[] nums, int k)
************************************************************************************************************
public class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        
        reverse(nums, 0, nums.length-1); // ARRAY.LENGTH - 1
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length-1);
    }
    
    private void reverse(int[] array, int left, int right){
        while(left < right) {
            int tem = array[left];
            array[left] = array[right];
            array[right] = tem;
            left++;
            right--;
        }
    }
}


************************************************************************************************************
*Problem 190 - Reverse Bits
*
*Description:Reverse bits of a given 32 bits unsigned integer. 
*	     For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), 
*	     return 964176192 (represented in binary as 00111001011110000010100101000000).
*	     Follow up: 
*	     If this function is called many times, how would you optimize it?
*	     Related problem: Reverse Integer
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
	    for (int i = 0; i < 16; i++) {
		    n = swapBits(n, i, 32 - i - 1);
	    }
 
	    return n;
    }
 
    public int swapBits(int n, int i, int j) {
	    int a = (n >> i) & 1;
	    int b = (n >> j) & 1;
 
	    if ((a ^ b) != 0) {
		    return n ^= (1 << i) | (1 << j);
	    }
 
	    return n;
    }
}


************************************************************************************************************
*Problem 191 - Number of 1 Bits
*
*Description:Write a function that takes an unsigned integer and returns the number of ’1' bits it has 
*	     (also known as the Hamming weight).
*	     For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, 
*	     so the function should return 3.
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i < 32; i++ ){
            if ((n>>>i & 1) == 1) count++;
        }
        return count;
    }
}


************************************************************************************************************
*Problem 196 - Delete Duplicate Emails
*
*Description:
*
Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.

+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id is the primary key column for this table.
For example, after running your query, the above Person table should have the following rows:

+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
*	     
*Parameter: 
************************************************************************************************************
DELETE p1
FROM Person p1, Person p2
WHERE p1.Email = p2.Email AND p1.Id > p2.Id


************************************************************************************************************
*Problem 198 - House Robber
*
*Description:You are a professional robber planning to rob houses along a street. Each house has a certain
*	     amount of money stashed, the only constraint stopping you from robbing each of them is that
*	     adjacent houses have security system connected and it will automatically contact the police if 
*	     two adjacent houses were broken into on the same night.
*
*	     Given a list of non-negative integers representing the amount of money of each house, determine 
*	     the maximum amount of money you can rob tonight without alerting the police.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int rob(int[] num) {
        int pre = 0, cur = 0;
        int tmp;
        for (int n :num) {
            tmp = cur;
            cur = Math.max(pre + n, cur);
            pre = tmp;
        }
        return cur;        
    }
}


************************************************************************************************************
*Problem 199 - Binary Tree Right Side View
*
*Description:Given a binary tree, imagine yourself standing on the right side of it, return the values of 
*	     the nodes you can see ordered from top to bottom.
*	     
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution1 {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        traverse(result, root, 1);
        return result;
    }

    void traverse(List<Integer> result, TreeNode node, int level) {
        if (node == null) return;
        if (level > result.size())
            result.add(node.val);

        traverse(result, node.right, level + 1);
        traverse(result, node.left, level + 1);
    }
}

public class Solution2 {
    public List<Integer> rightSideView(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        if(root == null) return result;
        Queue<TreeNode> current_layer = new LinkedList<>();
        current_layer.add(root);

        while(!current_layer.isEmpty()){
            TreeNode r = current_layer.poll();
            result.add(r.val);

            Queue<TreeNode> next_layer = new LinkedList<>();
            if(r.right != null) next_layer.add(r.right);
            if(r.left != null) next_layer.add(r.left);

            while(!current_layer.isEmpty()){
                TreeNode next = current_layer.poll();
                if(next.right != null) next_layer.add(next.right);
                if(next.left != null) next_layer.add(next.left);
            }

            current_layer = next_layer;
        }
        return result;
    }
}


************************************************************************************************************
*Problem 200 - Number of Islands (Surrounded Regions 130)
*
*Description:Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is 
*	     surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You 
*	     may assume all four edges of the grid are all surrounded by water.
*
*		Example 1:
*
*		11110
*		11010
*		11000
*		00000
*		Answer: 1
*		
*		Example 2:
*
*		11000
*		11000
*		00100
*		00011
*		Answer: 3
*	     
*Parameter: (char[][] grid)
************************************************************************************************************
public class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }

    private void dfs(char[][] grid, int i, int j) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == '0') return;

        grid[i][j] = '0';
        dfs(grid, i+1, j);
        dfs(grid, i-1, j);
        dfs(grid, i, j+1);
        dfs(grid, i, j-1);
        return;
    }
}


************************************************************************************************************
*Problem 202 - Happy Number
*
*Description:Write an algorithm to determine if a number is "happy".
*	     
*	     A happy number is a number defined by the following process: Starting with any positive integer, 
*	     replace the number by the sum of the squares of its digits, and repeat the process until the 
*	     number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. 
*	     Those numbers for which this process ends in 1 are happy numbers.
*
*	     Example: 19 is a happy number
*
*	     1^2 + 9^2 = 82
*	     8^2 + 2^2 = 68
*	     6^2 + 8^2 = 100
*	     1^2 + 0^2 + 0^2 = 1
*	     
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        while(n != 1) {
            if (!set.add(n))
                return false;
            n = getNextHappy(n);
        }
        return true;
    }
    
    private int getNextHappy(int n) {
        int sum = 0;
        while(n!=0) {
            sum+= (n%10)*(n%10);
            n/=10;
        }
        return sum;
    }
}


************************************************************************************************************
*Problem 203 - Remove Linked List Elements 
*
*Description:Remove all elements from a linked list of integers that have value val. 
*	     Example
*	     Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
*	     Return: 1 --> 2 --> 3 --> 4 --> 5
*
*Parameter: (ListNode head, int val)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = dummy; // DEPARTURE FROM DUMMY
        
        while(cur.next != null){ // UNTIL REACH LAST NODE (NOT ENTERING LAST NODE)
            if(cur.next.val == val){
                cur.next = cur.next.next;
            } else{
                cur = cur.next; // UPDATE
            }
        }
        return dummy.next;
    }
}


************************************************************************************************************
*Problem 204 - Count Primes 
*
*Description:Count Primes 
*	     
*	     Description:
*	     Count the number of prime numbers less than a non-negative number, n.
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public int countPrimes(int n) {
        if(n<=2) return 0;
        
        int num = 1;
        for(int i = 3; i < n; i++) {
            if(isPrime(i)) num++;
        }
        return num;
    }
    
    private boolean isPrime(int n) {
        if (n % 2 == 0) return false;
            
        for(int i = 3; i*i <= n; i+=2) {
            if (n%i == 0) return false;
        }

        return true;
    }
}


************************************************************************************************************
*Problem 205 - Isomorphic Strings
*
*Description: See website.
*
*Parameter: (String s, String t)
************************************************************************************************************
public class Solution {
    public boolean isIsomorphic(String s, String t) {
        if(s.length() != t.length()) return false;
        HashMap<Character, Character> hash = new HashMap<Character, Character>();
        for(int i = 0; i < s.length(); i++){
            if(hash.containsKey(s.charAt(i))){
                if(t.charAt(i) != hash.get(s.charAt(i))) return false;
            }else{
                if(hash.containsValue(t.charAt(i))) return false;
                else hash.put(s.charAt(i), t.charAt(i));
            }
        }
        return true;
    }
}


************************************************************************************************************
*Problem 206 - Reverse Linked List
*
*Description:Reverse a singly linked list.
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution1 {
    public ListNode reverseList(ListNode head) {

        ListNode prev = null;
        ListNode cur = head;
        
        while(cur != null){
            ListNode tem = cur.next;
            cur.next = prev;
            prev = cur;
            cur = tem;
        }
        return prev;
    }
}

public class Solution2 {
    public ListNode reverseList(ListNode head) {
        
        ListNode prev = null;
        ListNode cur = head;

        return reverse(prev, cur);
    }
    
    private ListNode reverse(ListNode prev, ListNode cur){
        if(cur == null) return prev;
        
        ListNode tem = cur.next;
        cur.next = prev;
        return reverse(cur, tem);
    }
}


************************************************************************************************************
*Problem 209 - Minimum Size Subarray Sum
*
*Description:Given an array of n positive integers and a positive integer s, find the minimal length of a 
*	     subarray of which the sum ≥ s. If there isn't one, return 0 instead.
*	     For example, given the array [2,3,1,2,4,3] and s = 7,
*	     the subarray [4,3] has the minimal length under the problem constraint.
*
*Parameter: (int s, int[] nums)
************************************************************************************************************
public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums.length == 0) return 0;
        
        int left = 0, right = 0;
        int currentSum = nums[0];
        int minLen = nums.length;
        
        while(left < nums.length) { // MOST LIKELY NOT REACHED
            if(currentSum < s){ // ADVANCE RIGHT
                if(right < nums.length - 1) {
                    right++;
                    currentSum += nums[right];
                } else { // RIGHT HITS BOUNDARY, NO NEED TO KEEP CHECKING UNDER THIS IF CONDITION
                    break;
                }
            } else { // ADVANCE LEFT
                if(left == right){ // SMALLEST RANGE
                    return 1;
                }
                if(right - left + 1 < minLen) {
                    minLen = right - left + 1;
                }
                currentSum -= nums[left];
                left++;
            }
        }
        
        if(left == 0 && right == nums.length - 1) {
            return 0;
        } else {
            return minLen;
        }
        
    }
}


************************************************************************************************************
*Problem 213 - House Robber II
*
*Description:Find the kth largest element in an unsorted array. Note that it is the kth largest element in 
*	     the sorted order, not the kth distinct element.
*
*		For example,
*		Given [3,2,1,5,6,4] and k = 2, return 5.
*
*		Note: 
*		You may assume k is always valid, 1 ≤ k ≤ array's length.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));
    }
    
    private int rob(int[] num, int lo, int hi) {
        int include = 0, exclude = 0;
        for (int j = lo; j <= hi; j++) {
            int i = include, e = exclude;
            include = e + num[j];
            exclude = Math.max(e, i);
        }
        return Math.max(include, exclude);
    }
}


************************************************************************************************************
*Problem 215 - Kth Largest Element in an Array
*
*Description:Find the kth largest element in an unsorted array. Note that it is the kth largest element in 
*	     the sorted order, not the kth distinct element.
*
*		For example,
*		Given [3,2,1,5,6,4] and k = 2, return 5.
*
*		Note: 
*		You may assume k is always valid, 1 ≤ k ≤ array's length.
*
*Parameter: (int[] nums, int k)
************************************************************************************************************
public class Solution {
    public int findKthLargest(int[] nums, int k) { // O(Nlgk)
        final int N = nums.length;
        Arrays.sort(nums);
        return nums[N - k];
    }
}

public class Solution {
    public int findKthLargest(int[] nums, int k) { // O(N)best/O(N^2)worst
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int val : nums) {
            pq.offer(val);
            if(pq.size() > k)
                pq.poll();
        }
        return pq.peek();
    }
}

public class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickselect(nums, nums.length - k, 0, nums.length - 1);
    }

    private int quickselect(int A[], int k, int left, int end) {        
        int mid = left;
        for (int i = mid; i < end; i++)// Take A[end] as the pivot, 
            if (A[i] <= A[end]) swap(A, mid++, i);// Put numbers < pivot to pivot's left
        swap(A, mid, end); // Finally, swap A[end] with A[mid] (mid is actually the index of the pivot A[end])

        if (mid == k) return A[mid];// Found kth smallest number
        else if (mid > k) return quickselect(A, k, left, mid - 1);// Check left part
        else return quickselect(A, k, mid + 1, end);// Check Right part
    }

    void swap(int A[], int i, int j) {
        int tmp = A[i];
        A[i] = A[j];
        A[j] = tmp;
    }
}


************************************************************************************************************
*Problem 216 - Combination Sum III 
*
*Description:Find all possible combinations of k numbers that add up to a number n, given that only numbers 
*	     from 1 to 9 can be used and each combination should be a unique set of numbers.
*	     
*	     Ensure that numbers within the set are sorted in ascending order.
*	     
*	     Example 1:
*	     Input: k = 3, n = 7
*	     Output:
*	       [[1,2,4]]
*	     
*	     Example 2:
*	     Input: k = 3, n = 9
*              Output:
*	       [[1,2,6], [1,3,5], [2,3,4]]
*
*Parameter: (int n, int k)
************************************************************************************************************
public class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<Integer> currentList = new ArrayList<>();
        List<List<Integer>> totalList = new ArrayList<List<Integer>>();
        dfs(1, currentList, totalList, k, n);
        return totalList;
    }
    
    private void dfs(int index, List<Integer> currentList, List<List<Integer>> totalList, int k, int n){
        if (currentList.size() ==  k && n == 0){
            totalList.add(new ArrayList<>(currentList));
            return;
        }
        
        if (currentList.size() == k){
            return;
        }
        
        for (int i = index; i <= 9; i++){
            currentList.add(i);
            dfs(i+1, currentList, totalList, k, n - i);
            currentList.remove(currentList.size() - 1);
        }
    }
}


************************************************************************************************************
*Problem 217 - Contains Duplicate
*
*Description:Given an array of integers, find if the array contains any duplicates.Your function should return 
*	     true if any value appears at least twice in the array, and it should return false if every element 
*	     is distinct.
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public boolean containsDuplicate(int[] nums) {
        if (nums.length < 2) return false;
        
        Set<Integer> set = new HashSet<Integer>();
        
        for (int i = 0; i < nums.length; i++){
            if(!set.add(nums[i])){
                return true;
            }
        }
        return false;
    }
}


************************************************************************************************************
*Problem 219 - Contains Duplicate II
*
*Description:Given an array of integers and an integer k, find out whether there there are two distinct 
*	     indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is 
*	     at most k.
*
*Parameter: (int[] nums, int k)
************************************************************************************************************
public class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        if(nums.length < 2) return false;
        
        Map<Integer, Integer> map = new HashMap<Integer,Integer>();
        
        for(int i = 0; i < nums.length; i++){
            if(map.containsKey(nums[i])) {
                if(i - map.get(nums[i]) <= k){
                    return true;
                }
            }
            map.put(nums[i], i);
        }
        return false;
    }
}


************************************************************************************************************
*Problem 221 - Maximal Square
*
*Description:Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's 
*	     and return its area.
*
*	     For example, given the following matrix: 
*	     
*	     1 0 1 0 0
*	     1 0 1 1 1
*	     1 1 1 1 1
*	     1 0 0 1 0
*
*	     Return 4.
*
*Parameter: (char[][] ak)
************************************************************************************************************
public class Solution {
    public int maximalSquare(char[][] a) {
        if (a == null || a.length == 0 || a[0].length == 0)
        return 0;

        int max = 0, n = a.length, m = a[0].length;

        // dp(i, j) represents the length of the square 
        // whose lower-right corner is located at (i, j)
        // dp(i, j) = min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }
        int[][] dp = new int[n + 1][m + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (a[i - 1][j - 1] == '1') {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                    max = Math.max(max, dp[i][j]);
                }
            }
        }

        // return the area
        return max * max;
    }
}


************************************************************************************************************
*Problem 225 - Implement Stack using Queues
*
*Description:Implement the following operations of a stack using queues.
*
*		  push(x) -- Push element x onto stack.
*	          pop() -- Removes the element on top of the stack.
*	          top() -- Get the top element.
*	          empty() -- Return whether the stack is empty.
*	     
*	     Notes:
*	          You must use only standard operations of a queue -- which means only push to back, peek/pop 
*	          from front, size, and is empty operations are valid.
*
*		  Depending on your language, queue may not be supported natively. You may simulate a queue 
*		  by using a list or deque (double-ended queue), as long as you use only standard operations 
*	          of a queue.
*	      
*	          You may assume that all operations are valid (for example, no pop or top operations will 
*	          be called on an empty stack).
*
*Parameter: 
************************************************************************************************************
class MyStack {
    LinkedList<Integer> queue1 = new LinkedList<Integer>();
    LinkedList<Integer> queue2 = new LinkedList<Integer>();
 
    // Push element x onto stack.
    public void push(int x) {
        if(empty()){
            queue1.offer(x);
        }else{
            if(queue1.size()>0){
                queue2.offer(x);
                int size = queue1.size();
                while(size>0){
                    queue2.offer(queue1.poll());
                    size--;
                }
            }else if(queue2.size()>0){
                queue1.offer(x);
                int size = queue2.size();
                while(size>0){
                    queue1.offer(queue2.poll());
                    size--;
                }
            }
        }
    }
 
    // Removes the element on top of the stack.
    public void pop() {
        if(queue1.size()>0){
            queue1.poll();
        }else if(queue2.size()>0){
            queue2.poll();
        }
    }
 
    // Get the top element.
    public int top() {
       if(queue1.size()>0){
            return queue1.peek();
        }else if(queue2.size()>0){
            return queue2.peek();
        }
        return 0;
    }
 
    // Return whether the stack is empty.
    public boolean empty() {
        return queue1.isEmpty() & queue2.isEmpty();
    }
}


************************************************************************************************************
*Problem 226 - Invert Binary Tree
*
*Description:Invert a binary tree.
*
*		  4
*	        /   \
*	       2     7
*	      / \   / \
*	     1   3 6   9
*
*	     to
*
*		4
*	      /   \
*	     7     2
*	    / \   / \
*	   9   6 3   1
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode invertTree(TreeNode root) {
    	helper(root);
    	return root;    
    }
 
    private void helper(TreeNode p){
        if (p == null) return;
        
        TreeNode temp = p.left;
        p.left = p.right;
        p.right = temp;
 
        helper(p.left);
        helper(p.right);
    }
}


************************************************************************************************************
*Problem 228 - Summary Ranges
*
*Description:Given a sorted integer array without duplicates, return the summary of its ranges.
*
*	     For example, given [0,1,2,4,5,7], return ["0->2","4->5","7"].
*
*Parameter: (TreeNode root, int k)
************************************************************************************************************
public class Solution {
    public List<String> summaryRanges(int[] nums) {
        int length = nums.length;
        List<String> result = new ArrayList<String>(length);

        for (int i = 0; i < length; i++) {
            int num = nums[i];
            while (i < length - 1 && nums[i] + 1 == nums[i + 1])
                i++;

            if (num != nums[i]) {
                result.add(num + "->" + nums[i]);
            } else {
                result.add(num + "");
            }
        }
        return result;
    }
}


************************************************************************************************************
*Problem 230 - Kth Smallest Element in a BST
*
*Description:Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
*
*Parameter: (TreeNode root, int k)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        List<TreeNode> list = new ArrayList<TreeNode>();
        inOederDFS(list, root);
        return list.get(k-1).val;
    }

    public void inOederDFS(List<TreeNode> list, TreeNode node){
        if(node == null) return;
        inOederDFS(list, node.left);
        list.add(node);
        inOederDFS(list, node.right);
    }
}


************************************************************************************************************
*Problem 231 - Power of Two
*
*Description:Given an integer, write a function to determine if it is a power of two.
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public boolean isPowerOfTwo(int n) {
        return ((n & (n-1))==0 && n>0);
    }
}


************************************************************************************************************
*Problem 232 - Implement Queue using Stacks 
*
*Description:Implement the following operations of a queue using stacks.
*
*		  push(x) -- Push element x to the back of queue.
*	          pop() -- Removes the element from in front of queue.
*	          peek() -- Get the front element.
*	          empty() -- Return whether the queue is empty.
*	     
*	     Notes:
*	          You must use only standard operations of a stack -- which means only push to top, peek/pop 
*		  from top, size, and is empty operations are valid.
*
*		  Depending on your language, stack may not be supported natively. You may simulate a stack 
*	          by using a list or deque (double-ended queue), as long as you use only standard operations 
*		  of a stack.
*	      
*	          You may assume that all operations are valid (for example, no pop or peek operations will 
*		  be called on an empty queue).
*
*Parameter: 
************************************************************************************************************
class MyQueue {
 
    Stack<Integer> temp = new Stack<Integer>();
    Stack<Integer> value = new Stack<Integer>();
 
    // Push element x to the back of queue.
    public void push(int x) {
        if(value.isEmpty()){
            value.push(x);
        }else{
            while(!value.isEmpty()){
                temp.push(value.pop());
            }
 
            value.push(x);
 
            while(!temp.isEmpty()){
                value.push(temp.pop());
            }    
        }
    }
 
    // Removes the element from in front of queue.
    public void pop() {
        value.pop();
    }
 
    // Get the front element.
    public int peek() {
        return value.peek();
    }
 
    // Return whether the queue is empty.
    public boolean empty() {
        return value.isEmpty();
    }
}


************************************************************************************************************
*Problem 234 - Palindrome Linked List (simplified Reorder list)
*
*Description:Given a singly linked list, determine if it is a palindrome. 
*
*Parameter: (ListNode head)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null){
            return true;
        }
        
        ListNode cur = head;
        ListNode slow = head, fast = head;
        
        while(fast.next != null && fast.next.next != null){ // SAME AS “/“ OPERATOR
            fast = fast.next.next;
            slow = slow.next;
        }
        
        ListNode newHead = reverseList(slow); // REVERSED IN MIDDLE POINT
        				      // ORIGINAL CHAIN REMAINS UNCUT
        while(newHead.next != null){ // SKIP THE LAST NODE
            if (cur.val != newHead.val){
                return false;
            }
            cur = cur.next;
            newHead = newHead.next;
        }
        return true;
    }
    
    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;
        
        while(cur != null){ // UNTIL WE REACH NULL (ENTERING LAST NODE)
            ListNode tem = cur.next;
            cur.next = prev; // BREAK THE LINK & RELINK
            prev = cur;
            cur = tem; // UPDATE
        }
        return prev; // RETUREN THE LAST NODE OF INITIAL CHAIN
    }
}


************************************************************************************************************
*Problem 235 - Lowest Common Ancestor of a Binary Search Tree
*
*Description:Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in 
*	     the BST. (See website)
*
*Parameter: (TreeNode root, TreeNode p, TreeNode q)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || p==null || q==null) return null;
        
        if(Math.max(p.val, q.val) < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if(Math.min(p.val, q.val) > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else return root;
    }
}


************************************************************************************************************
*Problem 236 - Lowest Common Ancestor of a Binary Tree
*
*Description:Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
*	     (See website)
*
*Parameter: (TreeNode root, TreeNode p, TreeNode q)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        return left == null ? right : right == null ? left : root;
    }
}


************************************************************************************************************
*Problem 237 - Delete Node in a Linked List 
*
*Description:Write a function to delete a node (except the tail) in a singly linked list, given only access 
*	     to that node. Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node
*	     with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.
*
*Parameter: (ListNode node)
************************************************************************************************************
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void deleteNode(ListNode node) {
        while(node.next.next != null){ // MUST BE node.next.next, WE NEED TO DISCARD THE LAST NODE
            node.val = node.next.val;
            node = node.next;
        }
        node.val = node.next.val;
        node.next = null;
    }
}


public class Solution {
    public void deleteNode(ListNode node) {
        if(node.next==null || node==null ) return ;

        node.val = node.next.val;
        node.next = node.next.next;
    }
}


************************************************************************************************************
*Problem 238 - Product of Array Except Self 
*
*Description:Given an array of n integers where n > 1, nums, return an array output such that output[i] is 
*	     equal to the product of all the elements of nums except nums[i]. 
*
*	     Solve it without division and in O(n).
*	     
*	     For example, given [1,2,3,4], return [24,12,8,6].
*
*	     Follow up:
*	     Could you solve it with constant space complexity? (Note: The output array does not count as 
*	     extra space for the purpose of space complexity analysis.)
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] output = new int[nums.length];

        // from left to right process
        // output[i] = product of all numbers left of i
        for (int i = 0; i < nums.length; i++) {
            if (i == 0) {
                output[i] = 1;
            } else {
                output[i] = output[i - 1] * nums[i - 1];
            }
        }

        // from right to left
        // t is the product of all numbers right of j
        for (int j = nums.length - 1, t = 1; j >= 0; j--) {
            // the final result
            output[j] = output[j] * t;
            t = t * nums[j];
        }

        return output;
    }
}


************************************************************************************************************
*Problem 240 - Search a 2D Matrix II
*
*Description:Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the 
*	     following properties:
*	     
*	     Integers in each row are sorted in ascending from left to right.
*	     Integers in each column are sorted in ascending from top to bottom.
*
*	     For example,
*	     Consider the following matrix:
*
*	     [
*	      [1,   4,  7, 11, 15],
*	      [2,   5,  8, 12, 19],
*	      [3,   6,  9, 16, 22],
*	      [10, 13, 14, 17, 24],
*	      [18, 21, 23, 26, 30]
*	     ]
*	     
*	     Given target = 5, return true.
*	     Given target = 20, return false.
*
*Parameter: (int[][] matrix, int target)
************************************************************************************************************
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
            return false;
        }
        int col = matrix[0].length-1;
        int row = 0;
        while(col >= 0 && row <= matrix.length-1) {
            if(target == matrix[row][col]) {
                return true;
            } else if(target < matrix[row][col]) {
                col--;
            } else if(target > matrix[row][col]) {
                row++;
            }
        }
        return false;
    }
}


************************************************************************************************************
*Problem 242 - Valid Anagram
*
*Description:Given two strings s and t, write a function to determine if t is an anagram of s. 
*	     For example,
*	     s = "anagram", t = "nagaram", return true.
*	     s = "rat", t = "car", return false.
*
*	     Note:
*	     You may assume the string contains only lowercase alphabets.
*
*Parameter: (String s, String t)
************************************************************************************************************
public class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        
        int[] map1 = new int[26];
        int[] map2 = new int[26];

        for (int i = 0; i < s.length(); i++) {
            map1[s.charAt(i)-'a']++;
        }
        for (int i = 0; i < t.length(); i++) {
            map2[t.charAt(i)-'a']++;
        }
        for (int i = 0; i < 26; i++) {
            if (map1[i] != map2[i]) {
                return false;
            }
        }
        return true; 
    }
}


************************************************************************************************************
*Problem 243 - Shortest Word Distance
*
*Description:Given a list of words and two words word1 and word2, return the shortest distance between these 
*	     two words in the list.
*	     For example,
*	     Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
*	     Given word1 = “coding”, word2 = “practice”, return 3.
*	     Given word1 = "makes", word2 = "coding", return 1.
*	     
*	     Note:
*	     You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.
*
*Parameter: (String[] words, String word1, String word2)
************************************************************************************************************
public class Solution {
    public int shortestDistance(String[] words, String word1, String word2) {
        int p1 = -1, p2 = -1, min = Integer.MAX_VALUE;
        
        for (int i = 0; i < words.length; i++) {
            if (words[i].equals(word1)) p1 = i;
            if (words[i].equals(word2)) p2 = i;
            if (p1 != -1 && p2 != -1) min = Math.min(min, Math.abs(p1 - p2));
        }
        return min;
    }
}


************************************************************************************************************
*Problem 244 - Shortest Word Distance II
*
*Description:This is a follow up of Shortest Word Distance. The only difference is now you are given the 
*	list of words and your method will be called repeatedly many times with different parameters. How 
*	would you optimize it?
*
*	Design a class which receives a list of words in the constructor, and implements a method that 
*	takes two words word1 and word2 and return the shortest distance between these two words in the list.
*
*	For example,
*	Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
*
*	Given word1 = “coding”, word2 = “practice”, return 3.
*	Given word1 = "makes", word2 = "coding", return 1.
*
*	Note:
*	You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.
*
*Parameter: (String[] words, String word1, String word2)
************************************************************************************************************
public class WordDistance {

    private Map<String, List<Integer>> map;

    public WordDistance(String[] words) {
        map = new HashMap<String, List<Integer>>();
        for(int i = 0; i < words.length; i++) {
            String w = words[i];
            if(map.containsKey(w)) {
                map.get(w).add(i);
            } else {
                List<Integer> list = new ArrayList<Integer>();
                list.add(i);
                map.put(w, list);
            }
        }
    }

    public int shortest(String word1, String word2) {
        List<Integer> list1 = map.get(word1);
        List<Integer> list2 = map.get(word2);
        int ret = Integer.MAX_VALUE;
        for(int i = 0, j = 0; i < list1.size() && j < list2.size(); ) {
            int index1 = list1.get(i), index2 = list2.get(j);
            if(index1 < index2) {
                ret = Math.min(ret, index2 - index1);
                i++;
            } else {
                ret = Math.min(ret, index1 - index2);
                j++;
            }
        }
        return ret;
    }
}

// Your WordDistance object will be instantiated and called as such:
// WordDistance wordDistance = new WordDistance(words);
// wordDistance.shortest("word1", "word2");
// wordDistance.shortest("anotherWord1", "anotherWord2");



************************************************************************************************************
*Problem 245 - Shortest Word Distance III
*
*Description:This is a follow up of Shortest Word Distance. The only difference is now word1 could be the 
*	same as word2.
*
*	Given a list of words and two words word1 and word2, return the shortest distance between these two 
*	words in the list.
*
*	word1 and word2 may be the same and they represent two individual words in the list.
*
*	For example,
*	Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
*
*	Given word1 = “makes”, word2 = “coding”, return 1.
*	Given word1 = "makes", word2 = "makes", return 3.
*
*	Note:
*	You may assume word1 and word2 are both in the list.
*
*Parameter: (String[] words, String word1, String word2)
************************************************************************************************************
public class Solution {
    public int shortestWordDistance(String[] words, String word1, String word2) {
        long dist = Integer.MAX_VALUE, i1 = dist, i2 = -dist;
        for (int i=0; i<words.length; i++) {
            if (words[i].equals(word1))
                i1 = i;
            if (words[i].equals(word2)) {
                if (word1.equals(word2))
                    i1 = i2;
                i2 = i;
            }
            dist = Math.min(dist, Math.abs(i1 - i2));
        }
        return (int) dist;
    }
}


************************************************************************************************************
*Problem 246 - Strobogrammatic Number
*
*Description:A strobogrammatic number is a number that looks the same when rotated 180 degrees 
*	(looked at upside down).
*
*	Write a function to determine if a number is strobogrammatic. The number is represented as a string.
*
*	For example, the numbers "69", "88", and "818" are all strobogrammatic.
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public boolean isStrobogrammatic(String num) {
        Map<Character, Character> map = new HashMap<Character, Character>() {{
            put('6', '9');
            put('9', '6');
            put('0', '0');
            put('1', '1');
            put('8', '8');
        }};
    
        int l = 0, r = num.length() - 1;
        while (l <= r) {
            if (!map.containsKey(num.charAt(l))) return false;
            if (map.get(num.charAt(l)) != num.charAt(r))
                return false;
            l++;
            r--;
        }

        return true;
    }
}


************************************************************************************************************
*Problem 247 - Strobogrammatic Number II
*
*Description:A strobogrammatic number is a number that looks the same when rotated 180 degrees 
*	(looked at upside down).
*
*	Find all strobogrammatic numbers that are of length = n.
*
*	For example,
*	Given n = 2, return ["11","69","88","96"].
*
*Parameter: (int n)
************************************************************************************************************
public class Solution {
    public List<String> findStrobogrammatic(int n) {
        return helper(n, n);
    }

    List<String> helper(int n, int m) {
        if (n == 0) return new ArrayList<String>(Arrays.asList(""));
        if (n == 1) return new ArrayList<String>(Arrays.asList("0", "1", "8"));

        List<String> list = helper(n - 2, m);

        List<String> res = new ArrayList<String>();

        for (int i = 0; i < list.size(); i++) {
            String s = list.get(i);

            if (n != m) res.add("0" + s + "0");

            res.add("1" + s + "1");
            res.add("6" + s + "9");
            res.add("8" + s + "8");
            res.add("9" + s + "6");
        }

        return res;
    }
}


************************************************************************************************************
*Problem 249 - Group Shifted Strings
*
*Description:Given a string, we can "shift" each of its letter to its successive letter, for example: 
*	”abc" -> "bcd". We can keep "shifting" which forms the sequence:
*
*	”abc" -> "bcd" -> ... -> "xyz"
*	Given a list of strings which contains only lowercase alphabets, group all strings that belong to 
*	the same shifting sequence.
*
*	For example, given: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"], 
*	Return:
*
*	[
*	  ["abc","bcd","xyz"],
*	  ["az","ba"],
*	  ["acef"],
*	  ["a","z"]
*	]
*	Note: For the return value, each inner list's elements must follow the lexicographic order.
*
*Parameter: (String[] strings)
************************************************************************************************************
public class Solution {
    public List<List<String>> groupStrings(String[] strings) {
        List<List<String>> res = new ArrayList<List<String>>();
        HashMap<String, List<String>> map = new HashMap<String, List<String>>();

        for(String word : strings){
            String key = "";
            int offset = word.charAt(0) - 'a';
            for(int i = 1; i < word.length(); i++){
                key += (word.charAt(i) - offset + 26) % 26;
            }

            if(!map.containsKey(key)){
                map.put(key, new ArrayList<String>());
            }
            map.get(key).add(word);
        }

        for(List<String> list : map.values()){
            Collections.sort(list);
            res.add(list);
        }

        return res;
    }
}


************************************************************************************************************
*Problem 252 - Meeting Rooms
*
*Description:Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] 
*	     (si < ei), determine if a person could attend all meetings.
*	     For example,
*	     Given [[0, 30],[5, 10],[15, 20]],
*	     return false.
*
*Parameter: (Interval[] intervals)
************************************************************************************************************
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public boolean canAttendMeetings(Interval[] intervals) {
        if (intervals == null) return false;

        // Sort the intervals by start time
        Arrays.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval a, Interval b) { return a.start - b.start; }
        });

        for (int i = 1; i < intervals.length; i++)
            if (intervals[i].start < intervals[i - 1].end)
                return false;

        return true;
    }
}


************************************************************************************************************
*Problem 253 - Meeting Rooms II
*
*Description:Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] 
*	     (si < ei), find the minimum number of conference rooms required. 

*	     For example,
*	     Given [[0, 30],[5, 10],[15, 20]],
*	     return 2.
*
*Parameter: (Interval[] intervals)
************************************************************************************************************
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution1 {
    public int minMeetingRooms(Interval[] intervals) {
        if (intervals == null || intervals.length == 0)
            return 0;

        Arrays.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval a, Interval b) { return a.start - b.start; }
        });

        PriorityQueue<Interval> heap = new PriorityQueue<Interval>(intervals.length, new Comparator<Interval>() {
            public int compare(Interval a, Interval b) { return a.end - b.end; }
        });

        heap.offer(intervals[0]);

        for (int i = 1; i < intervals.length; i++) {
            Interval interval = heap.poll();

            if (intervals[i].start >= interval.end) {
                interval.end = intervals[i].end;
            } else {
                heap.offer(intervals[i]);
            }

            heap.offer(interval);
        }

        return heap.size();
    }
}


public class Solution2 {
    public int minMeetingRooms(Interval[] intervals) {
        if(intervals == null || intervals.length == 0) return 0;
        Arrays.sort(intervals, (a, b) -> (a.start - b.start));
        int max = 0;
        PriorityQueue<Interval> queue = new PriorityQueue<>(intervals.length, (a, b) -> (a.end - b.end));
        for(int i = 0; i < intervals.length; i++){
            while(!queue.isEmpty() && intervals[i].start >= queue.peek().end)
                queue.poll();
            queue.offer(intervals[i]);
            max = Math.max(max, queue.size());
        }
        return max;
    }
}


************************************************************************************************************
*Problem 256 - Paint House
*
*Description:There are a row of n houses, each house can be painted with one of the three colors: red, blue 
*	     or green. The cost of painting each house with a certain color is different. You have to paint 
*	     all the houses such that no two adjacent houses have the same color.
*
*	     The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For
*	     example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of 
*	     painting house 1 with color green, and so on... Find the minimum cost to paint all houses.
*
*	     Note:
*	     All costs are positive integers. 
*
*Parameter: (TreeNode root)
************************************************************************************************************
public class Solution {
    public int minCost(int[][] costs) {
        if(costs==null||costs.length==0){
            return 0;
        }
        for(int i=1; i<costs.length; i++){
            costs[i][0] += Math.min(costs[i-1][1],costs[i-1][2]);
            costs[i][1] += Math.min(costs[i-1][0],costs[i-1][2]);
            costs[i][2] += Math.min(costs[i-1][1],costs[i-1][0]);
        }
        int n = costs.length-1;
        return Math.min(Math.min(costs[n][0], costs[n][1]), costs[n][2]);
    }
}


************************************************************************************************************
*Problem 257 - Binary Tree Paths
*
*Description:Given a binary tree, return all root-to-leaf paths. 
*
*Parameter: (TreeNode root)
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> answer = new ArrayList<String>();
        if (root != null) searchBT(root, "", answer);
        return answer;
    }
    
    private void searchBT(TreeNode root, String path, List<String> answer) {
        if (root.left == null && root.right == null) answer.add(path + root.val);
        if (root.left != null) searchBT(root.left, path + root.val + "->", answer);
        if (root.right != null) searchBT(root.right, path + root.val + "->", answer);
    }
}


************************************************************************************************************
*Problem 258 - Add Digits
*
*Description:Given a non-negative integer num, repeatedly add all its digits until the result has only one 
*	     digit.
*	     For example,
*	     Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return 
*	     it.
*
*Parameter: (int num)
************************************************************************************************************
public class Solution {
    public int addDigits(int num) {
        return (num - 1) % 9 + 1;
    }
}


************************************************************************************************************
*Problem 259 - 3Sum Smaller
*
*Description:Given an array of n integers nums and a target, find the number of index triplets i, j, k with 
*	     0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.
*
*	     For example, given nums = [-2, 0, 1, 3], and target = 2.
*
*	     Return 2. Because there are two triplets which sums are less than 2:
*
*		[-2, 0, 1]
*		[-2, 0, 3]
*	     Follow up:
*	     Could you solve it in O(n2) runtime?
*
*Parameter: (int[] nums, int target)
************************************************************************************************************
public class Solution {
    public int threeSumSmaller(int[] nums, int target) {
        int L = nums.length;
        Arrays.sort(nums);
        int count = 0;
        for(int i=0; i<L-2; i++) {
            int lo = i+1;
            int hi = L-1;
            while(lo<hi) {
                if(nums[i] + nums[lo] + nums[hi] < target) {
                    count += hi-lo;
                    lo++;
                }
                else
                    hi--;
            }
        }
        return count;
    }
}


************************************************************************************************************
*Problem 267 - Ugly Number
*
*Description:Write a program to check whether a given number is an ugly number.
*	     Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 
*	     are ugly while 14 is not ugly since it includes another prime factor 7.
*
*	     Note that 1 is typically treated as an ugly number.
*
*Parameter: (int num)
************************************************************************************************************
public class Solution {
    public boolean isUgly(int num) {
        if (num <= 0) return false;
        if (num == 1) return true;
        if (num % 2 == 0)
            return isUgly(num/2);
        if (num % 3 == 0)
            return isUgly(num/3);
        if (num % 5 == 0)
            return isUgly(num/5);
        return false;
    }
}


************************************************************************************************************
*Problem 266 - Palindrome Permutation
*
*Description:Given a string, determine if a permutation of the string could form a palindrome. 
*	     For example,
*	     "code" -> False, "aab" -> True, "carerac" -> True.
*
*Parameter: (String s)
************************************************************************************************************
public class Solution {
    public boolean canPermutePalindrome(String s) {
        Set<Character> set=new HashSet<Character>();
        for(int i=0; i<s.length(); ++i)
            if (!set.add(s.charAt(i)))
                set.remove(s.charAt(i));
        return set.size()<=1;
    }
}


************************************************************************************************************
*Problem 267 - Palindrome Permutation II
*
*Description:Given a string s, return all the palindromic permutations (without duplicates) of it. Return an
*	     empty list if no palindromic permutation could be form.
*
*	     For example:
*
*	     Given s = "aabb", return ["abba", "baab"].
*
*	     Given s = "abc", return [].
*
*Parameter: (String s)
************************************************************************************************************

************************************************************************************************************
*Problem 268 - Missing Number
*
*Description:Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is 
*	     missing from the array.
*	     For example,
*	     Given nums = [0, 1, 3] return 2.
*
*	     Note:
*	     Your algorithm should run in linear runtime complexity. Could you implement it using only 
*	     constant extra space complexity?
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public int missingNumber(int[] nums) { //xor
        int res = nums.length;
        for(int i=0; i<nums.length; i++){
            res ^= i;
            res ^= nums[i];
        }
        return res;
    }

    public int missingNumber(int[] nums) { //sum
        int len = nums.length;
        int sum = (0+len)*(len+1)/2;
        for(int i=0; i<len; i++)
            sum-=nums[i];
        return sum;
    }

    public int missingNumber(int[] nums) { //binary search
        Arrays.sort(nums);
        int left = 0, right = nums.length, mid= (left + right)/2;
        while(left<right){
            mid = (left + right)/2;
            if(nums[mid]>mid) right = mid;
            else left = mid+1;
        }
        return left;
    }
}


************************************************************************************************************
*Problem 276 - Paint Fence
*
*Description:There is a fence with n posts, each post can be painted with one of the k colors.
*
*	You have to paint all the posts such that no more than two adjacent fence posts have the same color.
*
*	Return the total number of ways you can paint the fence.
*
*	Note:
*	n and k are non-negative integers.
*
*Parameter: (int n, int k)
************************************************************************************************************
public int numWays(int n, int k) {
    if(n == 0) return 0;
    else if(n == 1) return k;
    int diffColorCounts = k*(k-1);
    int sameColorCounts = k;
    for(int i=2; i<n; i++) {
        int temp = diffColorCounts;
        diffColorCounts = (diffColorCounts + sameColorCounts) * (k-1);
        sameColorCounts = temp;
    }
    return diffColorCounts + sameColorCounts;
}


************************************************************************************************************
*Problem 280 - Wiggle Sort
*
*Description:Given an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= 
*	nums[3]....
*
*	For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public void wiggleSort(int[] a) {
        for (int i = 1; i < a.length; ++i) {
            if ((i%2 == 1) != (a[i] > a[i-1])) {
                int cache = a[i];
                a[i] = a[i-1];
                a[i-1] = cache;
            }
        }
    }
}


************************************************************************************************************
*Problem 283 - Move Zeroes
*
*Description:Given an array nums, write a function to move all 0's to the end of it while maintaining the 
*	     relative order of the non-zero elements.
*
*	     For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be 
*	     [1, 3, 12, 0, 0].
*
*Parameter: (int[] nums)
************************************************************************************************************
public class Solution {
    public void moveZeroes(int[] a) {
        int j = 0;
        for(int i = 0; i < a.length; i++) {
            if(a[i] != 0) {
                int temp = a[j];
                a[j] = a[i];
                a[i] = temp;
                j++;
            }
        }
    }
}


************************************************************************************************************
*Problem 285 - Inorder Successor in BST
*
*Description:Given a binary search tree and a node in it, find the in-order successor of that node in the BST.
*
*	     Note: If the given node has no in-order successor in the tree, return null.
*
*Parameter: (TreeNode root, TreeNode p)
************************************************************************************************************
public class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        if (root == null) return null;

        if (root.val <= p.val) {
            return  inorderSuccessor(root.right, p);
        } else {
            TreeNode left = inorderSuccessor(root.left, p);
            return (left != null) ? left : root;
        }
    }
}

public class Solution {
    public TreeNode predecessor(TreeNode root, TreeNode p) {
        if (root == null) return null;

        if (root.val >= p.val) {
            return predecessor(root.left, p);
        } else {
            TreeNode right = predecessor(root.right, p);
            return (right != null) ? right : root;
        }
    }
}


************************************************************************************************************
*Problem 297 - Serialize and Deserialize Binary Tree
*
*Description:
*
*Parameter:
************************************************************************************************************
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();    
        helperS(root, sb);
        return sb.toString();
    }

    private void helperS(TreeNode node, StringBuilder sb){
        if(node == null){
            sb.append("null").append(",");
            return;
        }
    
        sb.append(node.val).append(",");

        helperS(node.left, sb);
        helperS(node.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] vals  = data.split("[,]");
        int[]    index = new int[]{0};
        return helperD(vals, index);
    }

    private TreeNode helperD(String[] vals, int[] index){
        if(index[0] == vals.length){
            return null;
        }

        String visiting = vals[index[0]++];
        if(visiting.equals("null")){
            return null;
        }

        TreeNode node = new TreeNode(Integer.valueOf(visiting));
        node.left     = helperD(vals, index);
        node.right    = helperD(vals, index);

        return node;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));